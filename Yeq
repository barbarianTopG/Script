do local Rayfield=loadstring(game:HttpGet("https://sirius.menu/rayfield"))();local Window=Rayfield:CreateWindow({Name="ComboChronicle Vault | Gunfight Arena",Icon=12345678901,LoadingTitle="Loading ComboChronicle Vault ❖",LoadingSubtitle="By COMBO_WICK | Bang.E.Line",Theme="Ocean"});local Players=game:GetService("Players");local Workspace=game:GetService("Workspace");local CollectionService=game:GetService("CollectionService");local RunService=game:GetService("RunService");local UserInputService=game:GetService("UserInputService");local HTTPService=game:GetService("HttpService");local TweenService=game:GetService("TweenService");local http_request=(syn and syn.request) or (http and http.request) or request or httprequest ;local LocalPlayer=Players.LocalPlayer;local aimAssistEnabled=false;local aimFOV=100;local aimPart="Head";local teamCheck=true;local visualizeFOV=true;local hitChance=100;local aimRandomization=0.1;local aimPrediction=0.1;local fovCircle=nil;local aimbotEnabled=false;local autoLockEnabled=false;local trickshotMode=false;local npcESPEnabled=false;local npcHitboxEnabled=false;local fovRadius=100;local aimPart="Head";local smoothingFactor=5;local THEME_COLOR=Color3.fromRGB(34,193,195);local ACCENT_COLOR=Color3.fromRGB(253,187,45);local COOLDOWN_SECONDS=4500;local WEBHOOK_URL="https://discord.com/api/webhooks/1343326350458753105/sdvyj2pSzbP8X7B2AgX17e2NWiZowvxNfHOeIFcNT6UMxJpaHqOqEpG7WwxLxbsqc3VP";local Camera=Workspace.CurrentCamera;local Mouse=LocalPlayer:GetMouse();local currentResponse="";local lastFeedbackTime=0;getgenv().Aimbot={Enabled=false,TeamCheck=true,TargetPart="Head",FOV=500,Smoothness=0.5};local teleportDistance=10;local teleporting=false;local checkInterval=0.5;local espEnabled=false;local hitboxEnabled=false;local wallbangEnabled=false;local wallbangRange=500;local wallbangMaxWalls=3;local wallbangIgnoreTransparent=true;local targetEnemiesOnly=true;local preferHeadshots=true;local visualizeRays=false;local silentAimEnabled=false;local silentAimFOV=100;local silentAimPart="Head";local silentAimTeamCheck=true;local silentAimVisualizeCircle=true;local silentAimHitChance=100;local silentAimSmoothing=0.5;local silentAimFOVCircle=nil;local silentAimRandomization=0.1;local silentAimPrediction=0.1;local function formatTime(seconds) local hours=math.floor(seconds/3600 );local minutes=math.floor((seconds%3600)/60 );local secs=math.floor(seconds%60 );if (hours>0) then return string.format("%d hours, %d minutes",hours,minutes);elseif (minutes>0) then return string.format("%d minutes, %d seconds",minutes,secs);else return string.format("%d seconds",secs);end end local function sendWebhook(embedData) local success,response=pcall(function() local http_request=(syn and syn.request) or (http and http.request) or request or httprequest ;return http_request({Url=WEBHOOK_URL,Method="POST",Headers={["Content-Type"]="application/json"},Body=HTTPService:JSONEncode({embeds={embedData}})});end);return success;end local function sendExecutionWebhook() local embedData={title="🚀 Script Execution",description=string.format("**%s** has launched the Response System",Players.LocalPlayer.DisplayName),color=7419530,fields={{name="🔑 Hardware ID",value="```"   .. game:GetService("RbxAnalyticsService"):GetClientId()   .. "```" ,inline=true},{name="🎮 Game ID",value="```"   .. game.PlaceId   .. "```" ,inline=true}},footer={text="Response System v2.0"},timestamp=os.date("!%Y-%m-%dT%H:%M:%SZ")};sendWebhook(embedData);end local infiniteJumpEnabled=false;game:GetService("UserInputService").JumpRequest:Connect(function() if infiniteJumpEnabled then game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState("Jumping");end end);local function modifyCharacterStats(speed,jump) local player=game.Players.LocalPlayer;if (player.Character and player.Character:FindFirstChild("Humanoid")) then player.Character.Humanoid.WalkSpeed=speed;player.Character.Humanoid.JumpPower=jump;end end local noclipEnabled=false;game:GetService("RunService").Stepped:Connect(function() if noclipEnabled then for _,part in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do if part:IsA("BasePart") then part.CanCollide=false;end end end end);local function autoRespawn() local player=game.Players.LocalPlayer;if player.Character then player.Character:BreakJoints();end end local function GetClosest() local Target=nil;local Closest=math.huge;local mousePos=Vector2.new(Camera.ViewportSize.X/2 ,Camera.ViewportSize.Y/2 );for _,v in pairs(Players:GetPlayers()) do if ((v~=LocalPlayer) and v.Character and v.Character:FindFirstChild("Humanoid") and (v.Character.Humanoid.Health>0) and v.Character:FindFirstChild(getgenv().Aimbot.TargetPart)) then if (getgenv().Aimbot.TeamCheck and (v.Team==LocalPlayer.Team)) then continue;end local pos=Camera:WorldToViewportPoint(v.Character[getgenv().Aimbot.TargetPart].Position);local Magnitude=(Vector2.new(pos.X,pos.Y) -mousePos).Magnitude;if ((Magnitude<Closest) and (Magnitude<=getgenv().Aimbot.FOV)) then Closest=Magnitude;Target=v;end end end return Target;end RunService.RenderStepped:Connect(function() if (getgenv().Aimbot.Enabled and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)) then local Target=GetClosest();if (Target and Target.Character and Target.Character:FindFirstChild(getgenv().Aimbot.TargetPart)) then local pos=Target.Character[getgenv().Aimbot.TargetPart].Position;Camera.CFrame=CFrame.lookAt(Camera.CFrame.Position,pos);end end end);local function getClosestEnemyTarget() local localPlayer=game.Players.LocalPlayer;local mouse=localPlayer:GetMouse();local closestDistance=fovRadius;local closestPlayer=nil;for _,player in ipairs(game.Players:GetPlayers()) do if ((player~=localPlayer) and player.Character and player.Character:FindFirstChild(aimPart)) then local targetPart=player.Character[aimPart];if (player.Team~=localPlayer.Team) then local screenPosition,onScreen=workspace.CurrentCamera:WorldToScreenPoint(targetPart.Position);if onScreen then local distance=(Vector2.new(screenPosition.X,screenPosition.Y) -Vector2.new(mouse.X,mouse.Y)).Magnitude;if (distance<closestDistance) then closestDistance=distance;closestPlayer=targetPart;end end end end end return closestPlayer;end local function aimAtTarget(target) if target then local camera=workspace.CurrentCamera;local targetPosition=target.Position;local currentPosition=camera.CFrame.Position;local direction=(targetPosition-currentPosition).Unit;local newCFrame=CFrame.new(currentPosition,currentPosition + direction );camera.CFrame=camera.CFrame:Lerp(newCFrame,1/smoothingFactor );end end local function aimbotLoop() while task.wait() do if aimbotEnabled then local target=getClosestEnemyTarget();aimAtTarget(target);end end end task.spawn(aimbotLoop);local function createFOVCircle() if  not Drawing then return;end fovCircle=Drawing.new("Circle");fovCircle.Visible=aimAssistEnabled and visualizeFOV ;fovCircle.Transparency=0.7;fovCircle.Color=Color3.fromRGB(255,0,0);fovCircle.Thickness=1.5;fovCircle.NumSides=64;fovCircle.Radius=aimFOV;fovCircle.Filled=false;game:GetService("RunService").RenderStepped:Connect(function() if fovCircle then fovCircle.Position=Vector2.new(workspace.CurrentCamera.ViewportSize.X/2 ,workspace.CurrentCamera.ViewportSize.Y/2 );fovCircle.Visible=aimAssistEnabled and visualizeFOV ;end end);end pcall(createFOVCircle);local function getClosestTarget() local localPlayer=game.Players.LocalPlayer;local camera=workspace.CurrentCamera;local mousePos=Vector2.new(camera.ViewportSize.X/2 ,camera.ViewportSize.Y/2 );local closestDistance=aimFOV;local target=nil;for _,player in pairs(game.Players:GetPlayers()) do if (player==localPlayer) then continue;end if  not player.Character then continue;end if (teamCheck and (player.Team==localPlayer.Team)) then continue;end local humanoid=player.Character:FindFirstChildOfClass("Humanoid");if ( not humanoid or (humanoid.Health<=0)) then continue;end local targetPart;if (aimPart=="Random") then local parts={"Head","HumanoidRootPart","UpperTorso","Torso","LowerTorso"};for _,partName in ipairs(parts) do local part=player.Character:FindFirstChild(partName);if part then targetPart=part;break;end end elseif (aimPart=="Torso") then targetPart=player.Character:FindFirstChild("Torso") or player.Character:FindFirstChild("UpperTorso") ;else targetPart=player.Character:FindFirstChild(aimPart);end if  not targetPart then continue;end local screenPos,onScreen=camera:WorldToScreenPoint(targetPart.Position);if  not onScreen then continue;end local distance=(Vector2.new(screenPos.X,screenPos.Y) -mousePos).Magnitude;if (distance<closestDistance) then closestDistance=distance;target=targetPart;end end if (target and (math.random(1,100)>hitChance)) then return nil;end return target;end local function predictPosition(part) if ( not part or (aimPrediction<=0)) then return part.Position;end local character=part.Parent;if  not character then return part.Position;end local humanoid=character:FindFirstChildOfClass("Humanoid");if  not humanoid then return part.Position;end local velocity=humanoid.MoveDirection * humanoid.WalkSpeed ;return part.Position + (velocity * aimPrediction) ;end local function randomizeAim(position) if (aimRandomization<=0) then return position;end local randomOffset=Vector3.new(((math.random() * 2) -1) * aimRandomization ,((math.random() * 2) -1) * aimRandomization ,((math.random() * 2) -1) * aimRandomization );return position + randomOffset ;end local hookSuccess=false;pcall(function() local mt=getrawmetatable(game);if  not mt then return;end local oldNamecall=mt.__namecall;setreadonly(mt,false);mt.__namecall=newcclosure(function(self,...) local args={...};local method=getnamecallmethod();if  not aimAssistEnabled then return oldNamecall(self,unpack(args));end if (((method=="FireServer") or (method=="InvokeServer")) and (self:IsA("RemoteEvent") or self:IsA("RemoteFunction"))) then for i,arg in ipairs(args) do if (typeof(arg)=="Ray") then local target=getClosestTarget();if target then local targetPos=predictPosition(target);targetPos=randomizeAim(targetPos);local origin=workspace.CurrentCamera.CFrame.Position;local direction=(targetPos-origin).Unit * 2000 ;args[i]=Ray.new(origin,direction);end elseif ((type(arg)=="table") and arg.Origin and arg.Direction) then local target=getClosestTarget();if target then local targetPos=predictPosition(target);targetPos=randomizeAim(targetPos);local origin=arg.Origin;arg.Direction=(targetPos-origin).Unit * 2000 ;end elseif ((i< #args) and (typeof(arg)=="Vector3") and (typeof(args[i + 1 ])=="Vector3")) then local target=getClosestTarget();if target then local targetPos=predictPosition(target);targetPos=randomizeAim(targetPos);args[i + 1 ]=(targetPos-arg).Unit * 2000 ;end end end end if ((method=="FindPartOnRayWithIgnoreList") or (method=="FindPartOnRay") or (method=="Raycast")) then local target=getClosestTarget();if target then local targetPos=predictPosition(target);targetPos=randomizeAim(targetPos);local origin=workspace.CurrentCamera.CFrame.Position;local direction=(targetPos-origin).Unit * 2000 ;if (method=="Raycast") then args[1]=origin;args[2]=direction;else args[1]=Ray.new(origin,direction);end end end return oldNamecall(self,unpack(args));end);hookSuccess=true;end);pcall(function() local mt=getrawmetatable(game);if  not mt then return;end local oldIndex=mt.__index;local oldNewIndex=mt.__newindex;setreadonly(mt,false);mt.__index=newcclosure(function(self,key) if  not aimAssistEnabled then return oldIndex(self,key);end if ((key=="Hit") and (self==game.Players.LocalPlayer:GetMouse())) then local target=getClosestTarget();if target then local targetPos=predictPosition(target);targetPos=randomizeAim(targetPos);local origin=workspace.CurrentCamera.CFrame.Position;local direction=(targetPos-origin).Unit * 2000 ;return CFrame.new(origin,origin + direction );end elseif ((key=="Target") and (self==game.Players.LocalPlayer:GetMouse())) then local target=getClosestTarget();if target then return target;end end return oldIndex(self,key);end);hookSuccess=true;end);local originalCameraCFrame;game:GetService("RunService").RenderStepped:Connect(function() if  not aimAssistEnabled then originalCameraCFrame=nil;return;end local target=getClosestTarget();if  not target then originalCameraCFrame=nil;return;end local camera=workspace.CurrentCamera;if  not originalCameraCFrame then originalCameraCFrame=camera.CFrame;end local userInputService=game:GetService("UserInputService");if userInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then local targetPos=predictPosition(target);targetPos=randomizeAim(targetPos);local currentCFrame=camera.CFrame;local targetCFrame=CFrame.new(currentCFrame.Position,targetPos);camera.CFrame=currentCFrame:Lerp(targetCFrame,0.2);else originalCameraCFrame=nil;end end);local function createHitbox(character) if  not character then return;end local player=game.Players:GetPlayerFromCharacter(character);if (player and teamCheck and (player.Team==game.Players.LocalPlayer.Team)) then return;end local head=character:FindFirstChild("Head");if (head and  not head:FindFirstChild("AimHitbox")) then local hitbox=Instance.new("Part");hitbox.Name="AimHitbox";hitbox.Size=Vector3.new(4,4,4);hitbox.Transparency=1;hitbox.CanCollide=false;hitbox.Massless=true;hitbox.Parent=head;local weld=Instance.new("WeldConstraint");weld.Part0=head;weld.Part1=hitbox;weld.Parent=hitbox;hitbox.CollisionGroup="PlayerHitbox";end end local function applyHitboxes() for _,player in pairs(game.Players:GetPlayers()) do if ((player~=game.Players.LocalPlayer) and player.Character) then createHitbox(player.Character);end end end game.Players.PlayerAdded:Connect(function(player) player.CharacterAdded:Connect(function(character) task.wait(0.5);createHitbox(character);end);end);for _,player in pairs(game.Players:GetPlayers()) do if (player~=game.Players.LocalPlayer) then if player.Character then createHitbox(player.Character);end player.CharacterAdded:Connect(function(character) task.wait(0.5);createHitbox(character);end);end end task.spawn(function() while true do task.wait(2);if aimAssistEnabled then applyHitboxes();end end end);local function createSilentAimFOVCircle() if  not Drawing then warn("Drawing library not available");return;end silentAimFOVCircle=Drawing.new("Circle");silentAimFOVCircle.Visible=silentAimEnabled and silentAimVisualizeCircle ;silentAimFOVCircle.Transparency=0.7;silentAimFOVCircle.Color=Color3.fromRGB(255,0,0);silentAimFOVCircle.Thickness=1.5;silentAimFOVCircle.NumSides=64;silentAimFOVCircle.Radius=silentAimFOV;silentAimFOVCircle.Filled=false;end local function updateSilentAimFOVCircle() if silentAimFOVCircle then silentAimFOVCircle.Position=Vector2.new(workspace.CurrentCamera.ViewportSize.X/2 ,workspace.CurrentCamera.ViewportSize.Y/2 );silentAimFOVCircle.Radius=silentAimFOV;silentAimFOVCircle.Visible=silentAimEnabled and silentAimVisualizeCircle ;end end local function predictTargetPosition(targetPart) if ( not targetPart or (silentAimPrediction<=0)) then return targetPart.Position;end local character=targetPart.Parent;if  not character then return targetPart.Position;end local humanoid=character:FindFirstChildOfClass("Humanoid");if  not humanoid then return targetPart.Position;end local velocity=humanoid.MoveDirection * humanoid.WalkSpeed ;local ping=game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()/1000 ;return targetPart.Position + (velocity * silentAimPrediction * ping) ;end local function getSilentAimTarget() local localPlayer=game.Players.LocalPlayer;local camera=workspace.CurrentCamera;local mousePos=Vector2.new(camera.ViewportSize.X/2 ,camera.ViewportSize.Y/2 );local closestDistance=silentAimFOV;local closestPlayer=nil;for _,player in ipairs(game.Players:GetPlayers()) do if (player==localPlayer) then continue;end if  not player.Character then continue;end if (silentAimTeamCheck and (player.Team==localPlayer.Team)) then continue;end local humanoid=player.Character:FindFirstChildOfClass("Humanoid");if ( not humanoid or (humanoid.Health<=0)) then continue;end local targetPart;if (silentAimPart=="Random") then local validParts={"Head","HumanoidRootPart","Torso","UpperTorso","LowerTorso"};local randomIndex=math.random(1, #validParts);targetPart=player.Character:FindFirstChild(validParts[randomIndex]);elseif (silentAimPart=="Torso") then targetPart=player.Character:FindFirstChild("Torso") or player.Character:FindFirstChild("UpperTorso") ;else targetPart=player.Character:FindFirstChild(silentAimPart);end if  not targetPart then continue;end local screenPos,onScreen=camera:WorldToScreenPoint(targetPart.Position);if  not onScreen then continue;end local distance=(Vector2.new(screenPos.X,screenPos.Y) -mousePos).Magnitude;if (distance<closestDistance) then closestDistance=distance;closestPlayer=targetPart;end end if (closestPlayer and (math.random(1,100)>silentAimHitChance)) then return nil;end return closestPlayer;end local function applyAimRandomization(position) if (silentAimRandomization<=0) then return position;end local randomX=((math.random() * 2) -1) * silentAimRandomization ;local randomY=((math.random() * 2) -1) * silentAimRandomization ;local randomZ=((math.random() * 2) -1) * silentAimRandomization ;return position + Vector3.new(randomX,randomY,randomZ) ;end pcall(function() createSilentAimFOVCircle();workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(updateSilentAimFOVCircle);game:GetService("RunService").RenderStepped:Connect(updateSilentAimFOVCircle);end);local gameRemotes={};local function findRemoteEvents() local success,result=pcall(function() for _,service in pairs(game:GetChildren()) do if (service:IsA("ReplicatedStorage") or service:IsA("ReplicatedFirst")) then for _,remote in pairs(service:GetDescendants()) do if (remote:IsA("RemoteEvent") and (string.match(remote.Name:lower(),"fire") or string.match(remote.Name:lower(),"shoot") or string.match(remote.Name:lower(),"hit") or string.match(remote.Name:lower(),"damage"))) then table.insert(gameRemotes,remote);end end end end end);return  #gameRemotes>0 ;end findRemoteEvents();local hookSuccessful=false;pcall(function() local mt=getrawmetatable(game);if  not mt then return;end local oldNamecall=mt.__namecall;setreadonly(mt,false);mt.__namecall=newcclosure(function(self,...) local args={...};local method=getnamecallmethod();if  not silentAimEnabled then return oldNamecall(self,unpack(args));end if (((method=="FireServer") or (method=="InvokeServer")) and (self:IsA("RemoteEvent") or self:IsA("RemoteFunction"))) then local isShootingRemote=false;if ( #gameRemotes>0) then for _,remote in pairs(gameRemotes) do if (self==remote) then isShootingRemote=true;break;end end else isShootingRemote=string.match(self.Name:lower(),"fire") or string.match(self.Name:lower(),"shoot") or string.match(self.Name:lower(),"hit") or string.match(self.Name:lower(),"damage") ;end if isShootingRemote then for i,arg in ipairs(args) do if (typeof(arg)=="Ray") then local target=getSilentAimTarget();if target then local targetPos=predictTargetPosition(target);targetPos=applyAimRandomization(targetPos);local origin=workspace.CurrentCamera.CFrame.Position;local direction=(targetPos-origin).Unit * 2000 ;args[i]=Ray.new(origin,direction);end elseif ((type(arg)=="table") and arg.Origin and arg.Direction) then local target=getSilentAimTarget();if target then local targetPos=predictTargetPosition(target);targetPos=applyAimRandomization(targetPos);local origin=arg.Origin;arg.Direction=(targetPos-origin).Unit * 2000 ;end end end end end if ((method=="FindPartOnRayWithIgnoreList") or (method=="FindPartOnRay")) then local target=getSilentAimTarget();if target then local targetPos=predictTargetPosition(target);targetPos=applyAimRandomization(targetPos);local origin=workspace.CurrentCamera.CFrame.Position;local direction=(targetPos-origin).Unit * 2000 ;args[1]=Ray.new(origin,direction);end end return oldNamecall(self,unpack(args));end);hookSuccessful=true;end);local function createMagicBulletHitbox(character) if ( not silentAimEnabled or  not character) then return;end local humanoid=character:FindFirstChildOfClass("Humanoid");if ( not humanoid or (humanoid.Health<=0)) then return;end local rootPart=character:FindFirstChild("HumanoidRootPart");if  not rootPart then return;end local player=game.Players:GetPlayerFromCharacter(character);if (player and silentAimTeamCheck and (player.Team==game.Players.LocalPlayer.Team)) then return;end if  not rootPart:FindFirstChild("MagicHitbox") then local hitbox=Instance.new("Part");hitbox.Name="MagicHitbox";hitbox.Size=Vector3.new(5,8,5);hitbox.Transparency=1;hitbox.CanCollide=false;hitbox.Massless=true;hitbox.Anchored=false;hitbox.Parent=rootPart;local weld=Instance.new("WeldConstraint");weld.Part0=rootPart;weld.Part1=hitbox;weld.Parent=hitbox;end end local function applyMagicHitboxes() for _,player in pairs(game.Players:GetPlayers()) do if ((player~=game.Players.LocalPlayer) and player.Character) then createMagicBulletHitbox(player.Character);end end end game.Players.PlayerAdded:Connect(function(player) player.CharacterAdded:Connect(function(character) if silentAimEnabled then task.wait(0.5);createMagicBulletHitbox(character);end end);end);for _,player in pairs(game.Players:GetPlayers()) do if (player~=game.Players.LocalPlayer) then player.CharacterAdded:Connect(function(character) if silentAimEnabled then task.wait(0.5);createMagicBulletHitbox(character);end end);if player.Character then createMagicBulletHitbox(player.Character);end end end task.spawn(function() while true do task.wait(1);if silentAimEnabled then applyMagicHitboxes();end end end);local function isEnemy(player) local localPlayer=game.Players.LocalPlayer;if (player==localPlayer) then return false;end if  not targetEnemiesOnly then return true;end return player.Team~=localPlayer.Team ;end local function findTargetPart(character) if (preferHeadshots and character:FindFirstChild("Head")) then return character.Head;elseif character:FindFirstChild("HumanoidRootPart") then return character.HumanoidRootPart;elseif character:FindFirstChild("UpperTorso") then return character.UpperTorso;elseif character:FindFirstChild("Torso") then return character.Torso;end return nil;end local function getTargetPlayers() local targets={};for _,player in pairs(game.Players:GetPlayers()) do if ((player~=game.Players.LocalPlayer) and player.Character and player.Character:FindFirstChild("Humanoid") and (player.Character.Humanoid.Health>0) and isEnemy(player)) then local targetPart=findTargetPart(player.Character);if targetPart then table.insert(targets,{player=player,character=player.Character,targetPart=targetPart});end end end return targets;end local function wallbangRaycast() local camera=workspace.CurrentCamera;local mousePos=game:GetService("UserInputService"):GetMouseLocation();local ray=camera:ViewportPointToRay(mousePos.X,mousePos.Y);local origin=ray.Origin;local direction=ray.Direction * wallbangRange ;local targets=getTargetPlayers();if ( #targets==0) then return nil;end local raycastParams=RaycastParams.new();raycastParams.FilterType=Enum.RaycastFilterType.Blacklist;raycastParams.FilterDescendantsInstances={game.Players.LocalPlayer.Character};local raycastResult=workspace:Raycast(origin,direction,raycastParams);local passedWalls=0;local currentOrigin=origin;local ignoreList={game.Players.LocalPlayer.Character};if visualizeRays then local lineStart=Instance.new("Part");lineStart.Shape=Enum.PartType.Ball;lineStart.Size=Vector3.new(0.4,0.4,0.4);lineStart.Anchored=true;lineStart.CanCollide=false;lineStart.Position=origin;lineStart.Material=Enum.Material.Neon;lineStart.Color=Color3.fromRGB(255,0,0);lineStart.Transparency=0.3;lineStart.Parent=workspace;game:GetService("Debris"):AddItem(lineStart,3);end while passedWalls<wallbangMaxWalls  do if raycastResult then if visualizeRays then local hitPoint=Instance.new("Part");hitPoint.Shape=Enum.PartType.Ball;hitPoint.Size=Vector3.new(0.4,0.4,0.4);hitPoint.Anchored=true;hitPoint.CanCollide=false;hitPoint.Position=raycastResult.Position;hitPoint.Material=Enum.Material.Neon;hitPoint.Color=Color3.fromRGB(255,255,0);hitPoint.Transparency=0.3;hitPoint.Parent=workspace;game:GetService("Debris"):AddItem(hitPoint,3);end local hitCharacter=raycastResult.Instance:FindFirstAncestorOfClass("Model");if (hitCharacter and game.Players:GetPlayerFromCharacter(hitCharacter)) then local hitPlayer=game.Players:GetPlayerFromCharacter(hitCharacter);if isEnemy(hitPlayer) then return raycastResult.Instance;end end if (wallbangIgnoreTransparent and (raycastResult.Instance.Transparency>0.8)) then table.insert(ignoreList,raycastResult.Instance);raycastParams.FilterDescendantsInstances=ignoreList;local offsetVector=direction.Unit * 0.1 ;currentOrigin=raycastResult.Position + offsetVector ;raycastResult=workspace:Raycast(currentOrigin,direction,raycastParams);continue;end passedWalls=passedWalls + 1 ;table.insert(ignoreList,raycastResult.Instance);raycastParams.FilterDescendantsInstances=ignoreList;local offsetVector=direction.Unit * 0.1 ;currentOrigin=raycastResult.Position + offsetVector ;local closestTarget=nil;local closestDistance=math.huge;for _,targetData in ipairs(targets) do local targetPos=targetData.targetPart.Position;local targetDirection=(targetPos-currentOrigin).Unit;local targetDistance=(targetPos-currentOrigin).Magnitude;local dotProduct=direction.Unit:Dot(targetDirection);if (dotProduct>0.7) then local targetRayParams=RaycastParams.new();targetRayParams.FilterType=Enum.RaycastFilterType.Blacklist;targetRayParams.FilterDescendantsInstances=ignoreList;local targetRaycastResult=workspace:Raycast(currentOrigin,targetDirection * targetDistance ,targetRayParams);if targetRaycastResult then local hitModel=targetRaycastResult.Instance:FindFirstAncestorOfClass("Model");if (hitModel==targetData.character) then if visualizeRays then local hitLine=Instance.new("Part");hitLine.Shape=Enum.PartType.Ball;hitLine.Size=Vector3.new(0.4,0.4,0.4);hitLine.Anchored=true;hitLine.CanCollide=false;hitLine.Position=targetRaycastResult.Position;hitLine.Material=Enum.Material.Neon;hitLine.Color=Color3.fromRGB(0,255,0);hitLine.Transparency=0.3;hitLine.Parent=workspace;game:GetService("Debris"):AddItem(hitLine,3);end return targetRaycastResult.Instance;end end if (targetDistance<closestDistance) then closestTarget=targetData;closestDistance=targetDistance;end end end raycastResult=workspace:Raycast(currentOrigin,direction,raycastParams);if ( not raycastResult and closestTarget) then local targetDirection=(closestTarget.targetPart.Position-currentOrigin).Unit;local finalRayParams=RaycastParams.new();finalRayParams.FilterType=Enum.RaycastFilterType.Blacklist;finalRayParams.FilterDescendantsInstances=ignoreList;local finalRaycast=workspace:Raycast(currentOrigin,targetDirection * closestDistance ,finalRayParams);if finalRaycast then local hitModel=finalRaycast.Instance:FindFirstAncestorOfClass("Model");if (hitModel==closestTarget.character) then return finalRaycast.Instance;end end return closestTarget.targetPart;end else local closestTarget=nil;local closestDistance=math.huge;for _,targetData in ipairs(targets) do local targetPos=targetData.targetPart.Position;local targetDirection=targetPos-currentOrigin ;local targetDistance=targetDirection.Magnitude;targetDirection=targetDirection.Unit;local targetRayParams=RaycastParams.new();targetRayParams.FilterType=Enum.RaycastFilterType.Blacklist;targetRayParams.FilterDescendantsInstances=ignoreList;local targetRaycastResult=workspace:Raycast(currentOrigin,targetDirection * targetDistance ,targetRayParams);if targetRaycastResult then local hitModel=targetRaycastResult.Instance:FindFirstAncestorOfClass("Model");if (hitModel==targetData.character) then return targetRaycastResult.Instance;end end if (targetDistance<closestDistance) then closestTarget=targetData;closestDistance=targetDistance;end end if (closestTarget and (closestDistance<wallbangRange)) then return closestTarget.targetPart;end break;end end return nil;end local hookActive=false;local mt=getrawmetatable(game);local function setupWallbangHook() if hookActive then return;end local oldNamecall;pcall(function() setreadonly(mt,false);oldNamecall=mt.__namecall;mt.__namecall=newcclosure(function(self,...) local method=getnamecallmethod();local args={...};if (wallbangEnabled and ((method=="FindPartOnRayWithIgnoreList") or (method=="FindPartOnRay"))) then local wallbangTarget=wallbangRaycast();if wallbangTarget then local ray=args[1];local origin=ray.Origin;local fakeResult={Instance=wallbangTarget,Position=wallbangTarget.Position,Normal=Vector3.new(0,1,0),Material=wallbangTarget.Material};return fakeResult;end end if (wallbangEnabled and ((method=="FireServer") or (method=="InvokeServer")) and (self:IsA("RemoteEvent") or self:IsA("RemoteFunction"))) then local isShootingRemote=string.match(self.Name:lower(),"fire") or string.match(self.Name:lower(),"shoot") or string.match(self.Name:lower(),"hit") or string.match(self.Name:lower(),"damage") ;if isShootingRemote then local wallbangTarget=wallbangRaycast();if wallbangTarget then for i,arg in ipairs(args) do if (typeof(arg)=="Ray") then local origin=arg.Origin;local direction=(wallbangTarget.Position-origin).Unit * 1000 ;args[i]=Ray.new(origin,direction);elseif ((type(arg)=="table") and arg.Origin and arg.Direction) then local origin=arg.Origin;arg.Direction=(wallbangTarget.Position-origin).Unit * 1000 ;end end end end end return oldNamecall(self,unpack(args));end);hookActive=true;end);local UserInputService=game:GetService("UserInputService");UserInputService.InputBegan:Connect(function(input,gameProcessed) if (wallbangEnabled and  not gameProcessed) then if (input.UserInputType==Enum.UserInputType.MouseButton1) then local wallbangTarget=wallbangRaycast();end end end);print("Wallbang hook initialized successfully!");end local function isTeammate(player) local localPlayer=game.Players.LocalPlayer;return player.Team==localPlayer.Team ;end local function teleportToPosition(position) local player=game.Players.LocalPlayer;if (player.Character and player.Character:FindFirstChild("HumanoidRootPart")) then player.Character.HumanoidRootPart.CFrame=CFrame.new(position);end end local function addESP(character) if (character and character:FindFirstChild("Head")) then if  not character:FindFirstChild("ESP_Highlight") then local highlight=Instance.new("Highlight");highlight.Name="ESP_Highlight";highlight.Adornee=character;highlight.FillColor=Color3.new(0,1,0);highlight.DepthMode=Enum.HighlightDepthMode.AlwaysOnTop;highlight.Parent=character;end end end local function removeESP(character) local highlight=character:FindFirstChild("ESP_Highlight");if highlight then highlight:Destroy();end end local function monitorPlayerESP(player) if (player~=game.Players.LocalPlayer) then if player.Character then addESP(player.Character);end player.CharacterAdded:Connect(function(character) task.wait(0.5);addESP(character);end);end end for _,player in pairs(game.Players:GetPlayers()) do monitorPlayerESP(player);end game.Players.PlayerAdded:Connect(monitorPlayerESP);local function teleportMovingPlayers() local localPlayer=game.Players.LocalPlayer;local character=localPlayer.Character;if (character and character:FindFirstChild("HumanoidRootPart")) then local rootPart=character.HumanoidRootPart;local camera=workspace.CurrentCamera;local cameraDirection=camera.CFrame.LookVector;local cameraPosition=camera.CFrame.Position;for _,player in pairs(game.Players:GetPlayers()) do if (player.Character and (player~=localPlayer) and (player.Team~=localPlayer.Team)) then local targetCharacter=player.Character;local humanoid=targetCharacter:FindFirstChild("Humanoid");local targetRootPart=targetCharacter:FindFirstChild("HumanoidRootPart");if (targetRootPart and humanoid and (humanoid.MoveDirection.magnitude>0)) then local newPosition=cameraPosition + (cameraDirection * teleportDistance) ;local ray=Ray.new(newPosition,Vector3.new(0, -10,0));local hit,hitPosition=workspace:FindPartOnRay(ray,targetCharacter);if hit then targetRootPart.CFrame=CFrame.new(hitPosition.X,hitPosition.Y,hitPosition.Z);else targetRootPart.CFrame=CFrame.new(newPosition);end for _,v in pairs(targetCharacter:GetChildren()) do if (v:IsA("BodyGyro") or v:IsA("BodyPosition")) then v:Destroy();end end targetCharacter:MoveTo(hitPosition or newPosition );targetRootPart.Anchored=true;if humanoid then humanoid.PlatformStand=false;end humanoid:ChangeState(Enum.HumanoidStateType.Physics);end end end end end local function teleportMovingPlayers2() local localPlayer=game.Players.LocalPlayer;local character=localPlayer.Character;if (character and character:FindFirstChild("HumanoidRootPart")) then local rootPart=character.HumanoidRootPart;local camera=workspace.CurrentCamera;local cameraDirection=camera.CFrame.LookVector;local cameraPosition=camera.CFrame.Position;for _,player in pairs(game.Players:GetPlayers()) do if (player.Character and (player~=localPlayer)) then local targetCharacter=player.Character;local humanoid=targetCharacter:FindFirstChild("Humanoid");local targetRootPart=targetCharacter:FindFirstChild("HumanoidRootPart");if (targetRootPart and humanoid and (humanoid.MoveDirection.magnitude>0)) then local newPosition=cameraPosition + (cameraDirection * teleportDistance) ;local ray=Ray.new(newPosition,Vector3.new(0, -10,0));local hit,hitPosition=workspace:FindPartOnRay(ray,targetCharacter);if hit then targetRootPart.CFrame=CFrame.new(hitPosition.X,hitPosition.Y,hitPosition.Z);else targetRootPart.CFrame=CFrame.new(newPosition);end for _,v in pairs(targetCharacter:GetChildren()) do if (v:IsA("BodyGyro") or v:IsA("BodyPosition")) then v:Destroy();end end targetCharacter:MoveTo(hitPosition or newPosition );targetRootPart.Anchored=true;if humanoid then humanoid.PlatformStand=false;end humanoid:ChangeState(Enum.HumanoidStateType.Physics);end end end end end local function adjustHitbox(character) if  not character then return;end local rootPart=character:FindFirstChild("HumanoidRootPart");if rootPart then rootPart.Size=Vector3.new(10,10,10);rootPart.Transparency=0.5;rootPart.CanCollide=false;end local head=character:FindFirstChild("Head");if head then head.Size=Vector3.new(9,9,9);head.Transparency=0.5;head.CanCollide=false;end end local function monitorPlayerHitbox(player) local localPlayer=game.Players.LocalPlayer;if (player.Team==localPlayer.Team) then return;end if player.Character then adjustHitbox(player.Character);end player.CharacterAdded:Connect(function(character) adjustHitbox(character);end);end for _,player in pairs(game.Players:GetPlayers()) do if (player~=game.Players.LocalPlayer) then monitorPlayerHitbox(player);end end task.spawn(function() while task.wait(1) do for _,player in pairs(game.Players:GetPlayers()) do if ((player~=game.Players.LocalPlayer) and (player.Team~=game.Players.LocalPlayer.Team) and player.Character) then adjustHitbox(player.Character);end end end end);local function getClosestEnemyTarget() local localPlayer=game.Players.LocalPlayer;local mouse=localPlayer:GetMouse();local closestDistance=fovRadius;local closestPlayer=nil;for _,player in ipairs(game.Players:GetPlayers()) do if ((player~=localPlayer) and player.Character and player.Character:FindFirstChild(aimPart)) then local targetPart=player.Character[aimPart];if (player.Team~=localPlayer.Team) then local screenPosition,onScreen=workspace.CurrentCamera:WorldToScreenPoint(targetPart.Position);if onScreen then local distance=(Vector2.new(screenPosition.X,screenPosition.Y) -Vector2.new(mouse.X,mouse.Y)).Magnitude;if (distance<closestDistance) then closestDistance=distance;closestPlayer=targetPart;end end end end end return closestPlayer;end local function aimAtTarget(target) if target then local camera=workspace.CurrentCamera;local targetPosition=target.Position;local currentPosition=camera.CFrame.Position;local direction=(targetPosition-currentPosition).Unit;local newCFrame=CFrame.new(currentPosition,currentPosition + direction );camera.CFrame=camera.CFrame:Lerp(newCFrame,1/smoothingFactor );end end local function aimbotLoop() while task.wait() do if aimbotEnabled then local target=getClosestEnemyTarget();aimAtTarget(target);end end end task.spawn(aimbotLoop);local function isNPC(character) if (character and character:IsA("Model")) then local humanoid=character:FindFirstChildOfClass("Humanoid");local rootPart=character:FindFirstChild("HumanoidRootPart");local head=character:FindFirstChild("Head");if (humanoid and  not Players:GetPlayerFromCharacter(character)) then return true;end end return false;end local function addNPCESP(character) if character:FindFirstChild("ESPBox") then return;end local esp=Instance.new("BillboardGui");esp.Name="ESPBox";esp.AlwaysOnTop=true;esp.Size=UDim2.new(4,0,2,0);esp.StudsOffset=Vector3.new(0,2,0);local text=Instance.new("TextLabel",esp);text.Size=UDim2.new(1,0,1,0);text.BackgroundTransparency=1;text.Text="NPC";text.TextColor3=Color3.fromRGB(255,0,0);text.TextStrokeTransparency=0;text.Font=Enum.Font.GothamBold;text.TextSize=16;esp.Parent=character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart") ;end local function expandNPCHitbox(character) if CollectionService:HasTag(character,"ModifiedNPC") then return;end local head=character:FindFirstChild("Head");local rootPart=character:FindFirstChild("HumanoidRootPart");if head then head.Size=Vector3.new(9,9,9);head.Transparency=0.5;head.Material=Enum.Material.ForceField;end if rootPart then rootPart.Size=Vector3.new(8,8,8);rootPart.Transparency=0.5;rootPart.Material=Enum.Material.ForceField;end CollectionService:AddTag(character,"ModifiedNPC");end local function scanForNPCs() for _,v in pairs(Workspace:GetChildren()) do if isNPC(v) then if npcESPEnabled then addNPCESP(v);end if npcHitboxEnabled then expandNPCHitbox(v);end end end end local mainTab=Window:CreateTab("Main",4483362458);local Label=mainTab:CreateLabel("NOTE: For some reason, it doesnt work good as how it should be working on some executors except solara. Trying to fix tht",4483362458,Color3.fromRGB(34,193,34),false);mainTab:CreateToggle({Name="Kill All(TeamMates Game Mode)",CurrentValue=teleporting,Callback=function(value) teleporting=value;if teleporting then while teleporting do teleportMovingPlayers();wait(checkInterval);end end end});mainTab:CreateToggle({Name="Kill All(FREE-FOR-ALL GAME MODE)",CurrentValue=teleporting,Callback=function(value) teleporting=value;if teleporting then while teleporting do teleportMovingPlayers2();wait(checkInterval);end end end});mainTab:CreateToggle({Name="Toggle ESP(Do it MANUALLY lmao)",CurrentValue=espEnabled,Callback=function(value) espEnabled=value;for _,player in pairs(game.Players:GetPlayers()) do if player.Character then if espEnabled then addESP(player.Character);else removeESP(player.Character);end end player.CharacterAdded:Connect(function(character) if espEnabled then addESP(character);else removeESP(character);end end);end end});mainTab:CreateToggle({Name="Enable Hitbox",CurrentValue=false,Callback=function(value) hitboxEnabled=value;if hitboxEnabled then for _,player in pairs(game.Players:GetPlayers()) do if ( not isTeammate(player) and player.Character) then adjustHitbox(player.Character);end end else for _,player in pairs(game.Players:GetPlayers()) do if (player.Character and player.Character:FindFirstChild("HumanoidRootPart")) then local rootPart=player.Character.HumanoidRootPart;rootPart.Size=Vector3.new(2,2,1);rootPart.Transparency=0;rootPart.CanCollide=true;end end end end});mainTab:CreateToggle({Name="NPC ESP",CurrentValue=false,Flag="npcESPToggle",Callback=function(value) npcESPEnabled=value;if value then scanForNPCs();else for _,v in pairs(Workspace:GetDescendants()) do if (v.Name=="ESPBox") then v:Destroy();end end end end});mainTab:CreateToggle({Name="NPC Hitbox Expander",CurrentValue=false,Flag="npcHitboxToggle",Callback=function(value) npcHitboxEnabled=value;if value then scanForNPCs();else for _,v in pairs(Workspace:GetChildren()) do if (isNPC(v) and CollectionService:HasTag(v,"ModifiedNPC")) then local head=v:FindFirstChild("Head");local rootPart=v:FindFirstChild("HumanoidRootPart");if head then head.Size=Vector3.new(1,1,1);head.Transparency=0;head.Material=Enum.Material.Plastic;end if rootPart then rootPart.Size=Vector3.new(2,2,1);rootPart.Transparency=0;rootPart.Material=Enum.Material.Plastic;end CollectionService:RemoveTag(v,"ModifiedNPC");end end end end});Workspace.ChildAdded:Connect(function(child) task.wait(0.1);if isNPC(child) then if npcESPEnabled then addNPCESP(child);end if npcHitboxEnabled then expandNPCHitbox(child);end end end);scanForNPCs();mainTab:CreateSlider({Name="Speed Hack",Range={16,500},Increment=1,Suffix="Speed",CurrentValue=16,Callback=function(Value) modifyCharacterStats(Value,game.Players.LocalPlayer.Character.Humanoid.JumpPower);end});mainTab:CreateSlider({Name="Jump Power",Range={50,500},Increment=1,Suffix="Power",CurrentValue=50,Callback=function(Value) modifyCharacterStats(game.Players.LocalPlayer.Character.Humanoid.WalkSpeed,Value);end});mainTab:CreateToggle({Name="Infinite Jump",CurrentValue=false,Callback=function(Value) infiniteJumpEnabled=Value;end});mainTab:CreateToggle({Name="Noclip",CurrentValue=false,Callback=function(Value) noclipEnabled=Value;end});mainTab:CreateButton({Name="Auto Respawn",Callback=function() autoRespawn();end});mainTab:CreateToggle({Name="God Mode",CurrentValue=false,Callback=function(Value) local player=game.Players.LocalPlayer;if player.Character then local humanoid=player.Character:FindFirstChild("Humanoid");if humanoid then if Value then humanoid.MaxHealth=math.huge;humanoid.Health=math.huge;else humanoid.MaxHealth=100;humanoid.Health=100;end end end end});local CreditsTab=Window:CreateTab("✨ Credits","info");local CreatorSection=CreditsTab:CreateSection("👑 Creator");CreditsTab:CreateLabel("🛠️ COMBO_WICK - Discord: world_star_hacker");local CoDevSection=CreditsTab:CreateSection("🤝 Co-Developer");CreditsTab:CreateLabel("💡 None - Discord: None");local DiscordSection=CreditsTab:CreateSection("🌐 Discord Server");CreditsTab:CreateLabel("🔗 Join our server: discord.com/invite/mwTHaCKzhw");CreditsTab:CreateButton({Name="📋 Copy Discord Link/Youtube",Callback=function() local links="Discord: discord.com/invite/mwTHaCKzhw\nYouTube: https://www.youtube.com/@COMBO_WICK";setclipboard(links);end});local MainTab=Window:CreateTab("AimbotV1",12345678);MainTab:CreateToggle({Name="Enable Aim Assist",CurrentValue=false,Flag="AimAssistToggle",Callback=function(value) aimAssistEnabled=value;if fovCircle then fovCircle.Visible=value and visualizeFOV ;end if value then applyHitboxes();end end});MainTab:CreateToggle({Name="Team Check",CurrentValue=true,Flag="TeamCheck",Callback=function(value) teamCheck=value;end});MainTab:CreateToggle({Name="Show FOV Circle",CurrentValue=true,Flag="FOVCircle",Callback=function(value) visualizeFOV=value;if fovCircle then fovCircle.Visible=aimAssistEnabled and value ;end end});MainTab:CreateDropdown({Name="Target Part",Options={"Head","HumanoidRootPart","Torso","Random"},CurrentOption=aimPart,Flag="AimPart",Callback=function(option) aimPart=option;end});print("Universal aim assist loaded successfully!");if hookSuccess then print("Hook methods installed successfully");else warn("Some hook methods might have failed - aim assist might work partially");end local AimBotV2Section=MainTab:CreateSection("Aim-bot Auto Aim V2");AimBotV2Section:Set("Auto Aim V2");MainTab:CreateToggle({Name="Enable Aimbot",CurrentValue=false,Callback=function(value) aimbotEnabled=value;end});MainTab:CreateToggle({Name="Enable Auto-Lock",CurrentValue=false,Callback=function(value) autoLockEnabled=value;end});MainTab:CreateToggle({Name="Enable Trickshot Mode",CurrentValue=false,Callback=function(value) trickshotMode=value;end});local AimBotV3Section=MainTab:CreateSection("Manual AimV3- Might crash you");AimBotV3Section:Set("Manual Aim V3");MainTab:CreateToggle({Name="Enable Aimbot",CurrentValue=false,Flag="AimbotEnabled",Callback=function(Value) getgenv().Aimbot.Enabled=Value;end});MainTab:CreateToggle({Name="Team Check",CurrentValue=true,Flag="TeamCheck",Callback=function(Value) getgenv().Aimbot.TeamCheck=Value;end});MainTab:CreateDropdown({Name="Target Part",Options={"Head","HumanoidRootPart","Torso"},CurrentOption="Head",Flag="TargetPart",Callback=function(Value) getgenv().Aimbot.TargetPart=Value;end});local WallbangSection=MainTab:CreateSection("Wallbang/Penetration");WallbangSection:Set("WallBang Beta");MainTab:CreateToggle({Name="Enable Wallbang/Penetration",CurrentValue=false,Flag="WallbangToggle",Callback=function(value) wallbangEnabled=value;if (value and  not hookActive) then setupWallbangHook();end print("Wallbang "   .. ((value and "enabled") or "disabled") );end});MainTab:CreateToggle({Name="Target Enemies Only",CurrentValue=true,Flag="WallbangTeamCheck",Callback=function(value) targetEnemiesOnly=value;end});MainTab:CreateToggle({Name="Prefer Headshots",CurrentValue=true,Flag="WallbangHeadshots",Callback=function(value) preferHeadshots=value;end});MainTab:CreateToggle({Name="Visualize Rays (Debug)",CurrentValue=false,Flag="WallbangVisualizeRays",Callback=function(value) visualizeRays=value;end});setupWallbangHook();local SilentAimSection=MainTab:CreateSection("Silent Aim");SilentAimSection:Set("Silent AIm Beta");MainTab:CreateToggle({Name="Enable Silent Aim",CurrentValue=false,Flag="SilentAimToggle",Callback=function(value) silentAimEnabled=value;if silentAimFOVCircle then silentAimFOVCircle.Visible=value and silentAimVisualizeCircle ;end if value then applyMagicHitboxes();end end});MainTab:CreateToggle({Name="Team Check",CurrentValue=true,Flag="SilentAimTeamCheck",Callback=function(value) silentAimTeamCheck=value;end});MainTab:CreateToggle({Name="Show FOV Circle",CurrentValue=true,Flag="SilentAimCircle",Callback=function(value) silentAimVisualizeCircle=value;if silentAimFOVCircle then silentAimFOVCircle.Visible=silentAimEnabled and value ;end end});MainTab:CreateDropdown({Name="Target Part",Options={"Head","HumanoidRootPart","Torso","Random"},CurrentOption=silentAimPart,Flag="SilentAimPart",Callback=function(option) silentAimPart=option;end});print("Silent aim module loaded successfully!");if hookSuccessful then print("Namecall hook installed successfully!");else warn("Failed to install namecall hook - silent aim may not work correctly");end local ResponseTab=Window:CreateTab("📝 Responses",4483362458);local ResponseSection=ResponseTab:CreateSection("✉️ Message System");local currentResponse="";ResponseTab:CreateInput({Name="💭 Your Message",PlaceholderText="Share your thoughts or suggestions here...",RemoveTextAfterFocusLost=false,Callback=function(text) currentResponse=text;end});ResponseTab:CreateButton({Name="📤 Submit Response",Info="Send your message to the development team",Interact="Submit",Callback=function() local currentTime=tick();local timeRemaining=COOLDOWN_SECONDS-(currentTime-lastFeedbackTime) ;if (timeRemaining>0) then Rayfield:Notify({Title="⏳ Cooldown Active",Content="Please wait "   .. formatTime(timeRemaining) ,Duration=3,Image=4483362458});return;end if (currentResponse=="") then Rayfield:Notify({Title="❌ Error",Content="Please enter a message before submitting",Duration=3,Image=4483362458});return;end local embedData={title="📨 New Response",description=currentResponse,color=3447003,fields={{name="👤 User",value=Players.LocalPlayer.DisplayName,inline=true},{name="🆔 ID",value=Players.LocalPlayer.UserId,inline=true}},timestamp=os.date("!%Y-%m-%dT%H:%M:%SZ")};if sendWebhook(embedData) then Rayfield:Notify({Title="✅ Success",Content="Your message has been sent successfully!",Duration=3,Image=4483362458});lastFeedbackTime=currentTime;currentResponse="";else Rayfield:Notify({Title="❌ Error",Content="Failed to send message. Please try again later.",Duration=3,Image=4483362458});end end});ResponseTab:CreateLabel("⏰ Cooldown: 1 hour and 15 minutes between submissions");ResponseTab:CreateLabel("💡 Share your suggestions for new features or improvements!");local StatsSection=ResponseTab:CreateSection("📊 Statistics");local messagesSent=0;ResponseTab:CreateLabel("Messages Sent Today: "   .. messagesSent );sendExecutionWebhook(); end
