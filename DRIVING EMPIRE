if not game:IsLoaded() then
    game.Loaded:Wait()
end

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local PhysicsService = game:GetService("PhysicsService")
local UserInputService = game:GetService("UserInputService")
local VirtualUser = game:GetService("VirtualUser")

local START_POS = Vector3.new(-18249.7, 35.1, -676.0)
local END_POS = Vector3.new(-34551.8, 34.0, -32828.1)
local GROUND_HEIGHT = 35.1
local DETECTION_THRESHOLD = 50
local TELEPORT_DELAY = 0.5
local PHYSICS_UPDATE_RATE = 0.05
local ANCHOR_STRENGTH = 20000
local VELOCITY_DAMPING = 0.95
local DEFAULT_SPEED = 200
local STABILIZE_TIMER = 15
local ANTI_AFK_INTERVAL = 60
local FLOAT_OFFSET = 0.5

local Rayfield
local success, err = pcall(function()
    Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
end)

if not success then
    warn("Failed to load Rayfield: " .. tostring(err))
    Rayfield = nil
end

local function getPlayerVehicle()
    local character = LocalPlayer.Character
    if not character then return nil end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or not humanoid.SeatPart then return nil end
    
    local seat = humanoid.SeatPart
    if seat:IsA("VehicleSeat") or seat.Name == "DriveSeat" then
        return seat.Parent
    end
    
    local vehicleChecks = {
        function() return workspace.Vehicles:FindFirstChild(LocalPlayer.Name .. "sCar") end,
        function() return workspace.CarCollection[LocalPlayer.Name] end,
        function()
            for _, vehicle in pairs(workspace.Vehicles:GetChildren()) do
                local server = vehicle:FindFirstChild("Server")
                if server and server:FindFirstChild("Player") and server.Player.Value == LocalPlayer then
                    return vehicle
                end
            end
        end
    }
    
    for _, check in ipairs(vehicleChecks) do
        local result = pcall(check)
        if result then return result end
    end
    return nil
end

local function clearPhysicsObjects(part)
    if not part then return end
    for _, obj in pairs(part:GetChildren()) do
        if obj:IsA("BodyVelocity") or obj:IsA("BodyPosition") or obj:IsA("BodyGyro") then
            obj:Destroy()
        end
    end
end

local function raycastGround(position)
    local rayOrigin = position + Vector3.new(0, 50, 0)
    local rayDirection = Vector3.new(0, -100, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, getPlayerVehicle()}
    
    local success, result = pcall(function()
        return workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    end)
    if success and result then
        return result.Position.Y + FLOAT_OFFSET
    end
    return GROUND_HEIGHT + FLOAT_OFFSET
end

local function setVehicleSpeed(vehicle, speed, direction)
    if not vehicle then return false end
    
    local primary = vehicle.PrimaryPart or vehicle:FindFirstChild("Body")
    if not primary then return false end
    
    clearPhysicsObjects(primary)
    
    local groundY = raycastGround(primary.Position)
    local velocityDir = direction.Unit
    
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(math.huge, 0, math.huge)
    bv.Velocity = Vector3.new(velocityDir.X, 0, velocityDir.Z) * speed
    bv.Parent = primary
    
    local bp = Instance.new("BodyPosition")
    bp.MaxForce = Vector3.new(0, ANCHOR_STRENGTH, 0)
    bp.Position = Vector3.new(primary.Position.X, groundY, primary.Position.Z)
    bp.P = ANCHOR_STRENGTH
    bp.D = 1000
    bp.Parent = primary
    
    local bg = Instance.new("BodyGyro")
    bg.MaxTorque = Vector3.new(0, math.huge, 0)
    bg.CFrame = CFrame.new(primary.Position, primary.Position + velocityDir)
    bg.P = 5000
    bg.D = 500
    bg.Parent = primary
    
    return true
end

local function teleportVehicle(vehicle, position)
    if not vehicle then return false end
    
    local primary = vehicle.PrimaryPart or vehicle:FindFirstChild("Body")
    if not primary then return false end
    
    clearPhysicsObjects(primary)
    
    local direction = (END_POS - START_POS).Unit
    local groundY = raycastGround(position)
    local newCFrame = CFrame.new(position.X, groundY + 3, position.Z) * CFrame.lookAt(position, position + direction)
    
    primary.Velocity = Vector3.new(0, 0, 0)
    primary.RotVelocity = Vector3.new(0, 0, 0)
    primary.CFrame = newCFrame
    
    for _, part in pairs(vehicle:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Velocity = Vector3.new(0, 0, 0)
            part.RotVelocity = Vector3.new(0, 0, 0)
        end
    end
    
    wait(0.1)
    local speed = tonumber(speedInput and speedInput.CurrentValue or "200") or DEFAULT_SPEED
    return setVehicleSpeed(vehicle, speed, direction)
end

local function teleportCharacter(position)
    local character = LocalPlayer.Character
    if not character then return false end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end
    
    local groundY = raycastGround(position)
    local newCFrame = CFrame.new(position.X, groundY + 3, position.Z)
    
    humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
    humanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
    humanoidRootPart.CFrame = newCFrame
    
    return true
end

local function maintainGroundLevel(vehicle)
    if not vehicle then return end
    local primary = vehicle.PrimaryPart or vehicle:FindFirstChild("Body")
    if not primary then return end
    
    local bp = primary:FindFirstChildOfClass("BodyPosition")
    if bp then
        local groundY = raycastGround(primary.Position)
        bp.Position = Vector3.new(primary.Position.X, groundY, primary.Position.Z)
    end
end

local autofarmRunning = false
local isHeadingToEnd = true
local function startAutofarm()
    if autofarmRunning then return end
    autofarmRunning = true
    
    spawn(function()
        local lastVehicle = nil
        while autofarmRunning do
            local vehicle = getPlayerVehicle()
            
            if vehicle then
                if vehicle ~= lastVehicle then
                    local direction = isHeadingToEnd and (END_POS - START_POS) or (START_POS - END_POS)
                    teleportVehicle(vehicle, START_POS)
                    setVehicleSpeed(vehicle, tonumber(speedInput and speedInput.CurrentValue or "200") or DEFAULT_SPEED, direction)
                    lastVehicle = vehicle
                end
                
                maintainGroundLevel(vehicle)
                
                local primary = vehicle.PrimaryPart or vehicle:FindFirstChild("Body")
                if primary then
                    local targetPos = isHeadingToEnd and END_POS or START_POS
                    local distance = (primary.Position - targetPos).Magnitude
                    if distance < DETECTION_THRESHOLD then
                        isHeadingToEnd = not isHeadingToEnd
                        local newDirection = isHeadingToEnd and (END_POS - START_POS) or (START_POS - END_POS)
                        if teleportVehicle(vehicle, isHeadingToEnd and START_POS or END_POS) then
                            setVehicleSpeed(vehicle, tonumber(speedInput and speedInput.CurrentValue or "200") or DEFAULT_SPEED, newDirection)
                            wait(TELEPORT_DELAY)
                        else
                            wait(1)
                        end
                    end
                end
                
                wait(PHYSICS_UPDATE_RATE)
            else
                lastVehicle = nil
                wait(1)
            end
        end
        
        if lastVehicle then
            clearPhysicsObjects(lastVehicle.PrimaryPart or lastVehicle:FindFirstChild("Body"))
        end
    end)
end

local antiAfkRunning = false
local function startAntiAfk()
    if antiAfkRunning then return end
    antiAfkRunning = true
    
    spawn(function()
        while antiAfkRunning do
            local attempts = {
                function()
                    VirtualUser:CaptureController()
                    VirtualUser:ClickButton1(Vector2.new(0, 0))
                    VirtualUser:Button1Up(Vector2.new(0, 0))
                    return true
                end,
                function()
                    local camera = workspace.CurrentCamera
                    local originalCFrame = camera.CFrame
                    camera.CFrame = originalCFrame * CFrame.Angles(0, math.rad(1), 0)
                    wait(0.1)
                    camera.CFrame = originalCFrame
                    return true
                end,
                function()
                    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        humanoid:Move(Vector3.new(0.1, 0, 0))
                        wait(0.1)
                        humanoid:Move(Vector3.new(-0.1, 0, 0))
                        return true
                    end
                    return false
                end,
                function()
                    UserInputService:SendEvent("MouseMove", Vector2.new(1, 1))
                    wait(0.1)
                    UserInputService:SendEvent("MouseMove", Vector2.new(-1, -1))
                    return true
                end
            }
            
            local success = false
            for i, attempt in ipairs(attempts) do
                local ok, result = pcall(attempt)
                if ok and result then
                    success = true
                    if statusLabel then statusLabel:Set("Anti-AFK: Method " .. i .. " succeeded" .. (autofarmRunning and " | Autofarm running" or "")) end
                    break
                end
            end
            
            if not success and statusLabel then
                statusLabel:Set("Anti-AFK: All methods failed, still active" .. (autofarmRunning and " | Autofarm running" or ""))
            end
            
            wait(ANTI_AFK_INTERVAL)
        end
        if statusLabel then statusLabel:Set("Anti-AFK stopped" .. (autofarmRunning and " | Autofarm running" or "")) end
    end)
end

local function stopAntiAfk()
    antiAfkRunning = false
end

local Window, MainTab, speedInput, applyButton, toggleButton, teleportButton, forceTeleportButton, statusLabel, antiAfkToggle, stabilizeToggle, customTimerInput

local function setupGUI()
    if not Rayfield then
        print("GUI not available - using console commands")
        return false
    end
    
    Window = Rayfield:CreateWindow({
        Name = "Vehicle Autofarm Control",
        LoadingTitle = "Loading Vehicle Autofarm",
        LoadingSubtitle = "Powered by Rayfield",
        ConfigurationSaving = {
            Enabled = true,
            FolderName = "VehicleControl",
            FileName = "CarConfig"
        }
    })
    
    MainTab = Window:CreateTab("Main Controls")
    
    speedInput = MainTab:CreateInput({
        Name = "Speed",
        PlaceholderText = "Enter Speed (Default: 200)",
        RemoveTextAfterFocusLost = false,
        Callback = function(Value)
            local vehicle = getPlayerVehicle()
            local speed = tonumber(Value)
            if speed and vehicle then
                local direction = isHeadingToEnd and (END_POS - START_POS) or (START_POS - END_POS)
                setVehicleSpeed(vehicle, speed, direction)
                if statusLabel then statusLabel:Set("Speed applied: " .. speed) end
            else
                if statusLabel then statusLabel:Set("Invalid speed or no vehicle!") end
            end
        end
    })
    
    applyButton = MainTab:CreateButton({
        Name = "Apply Speed",
        Callback = function()
            local vehicle = getPlayerVehicle()
            local speed = tonumber(speedInput.CurrentValue) or DEFAULT_SPEED
            if vehicle then
                local direction = isHeadingToEnd and (END_POS - START_POS) or (START_POS - END_POS)
                setVehicleSpeed(vehicle, speed, direction)
                if statusLabel then statusLabel:Set("Speed applied: " .. speed) end
            else
                if statusLabel then statusLabel:Set("No vehicle found!") end
            end
        end
    })
    
    toggleButton = MainTab:CreateToggle({
        Name = "Start/Stop Cycle(BETA)",
        CurrentValue = false,
        Callback = function(Value)
            autofarmRunning = Value
            if Value then
                isHeadingToEnd = true
                startAutofarm()
                if statusLabel then statusLabel:Set("Driving to end position...") end
            else
                if statusLabel then statusLabel:Set("Autofarm stopped" .. (antiAfkRunning and " | Anti-AFK: Active" or "")) end
            end
        end
    })
    
    teleportButton = MainTab:CreateButton({
        Name = "Teleport Start",
        Callback = function()
            if teleportCharacter(START_POS) then
                if statusLabel then statusLabel:Set("Teleported to start position!") end
            else
                if statusLabel then statusLabel:Set("Teleport failed!") end
            end
        end
    })
    
    forceTeleportButton = MainTab:CreateButton({
        Name = "Force Teleport",
        Callback = function()
            local player = game:GetService("Players").LocalPlayer
            if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                player.Character.HumanoidRootPart.CFrame = CFrame.new(START_POS)
                if statusLabel then statusLabel:Set("Directly teleported to start position") end
                isHeadingToEnd = true
            else
                if statusLabel then statusLabel:Set("Force teleport failed!") end
            end
        end
    })
    
    antiAfkToggle = MainTab:CreateToggle({
        Name = "Anti-AFK",
        CurrentValue = false,
        Callback = function(Value)
            if Value then
                startAntiAfk()
                if statusLabel then statusLabel:Set("Anti-AFK system started" .. (autofarmRunning and " | Autofarm running" or "")) end
            else
                stopAntiAfk()
                if statusLabel then statusLabel:Set("Anti-AFK system stopped" .. (autofarmRunning and " | Autofarm running" or "")) end
            end
        end
    })
    
    stabilizeToggle = MainTab:CreateButton({
        Name = "Stabilize & Toggle Direction",
        Callback = function()
            _G.stabilizeAndToggleWithTimer()
        end
    })
    
    customTimerInput = MainTab:CreateInput({
        Name = "Stabilize Timer (seconds)",
        PlaceholderText = "Enter time (default: 15)",
        RemoveTextAfterFocusLost = false,
        Callback = function(Value)
            local newTime = tonumber(Value)
            if newTime and newTime > 0 then
                STABILIZE_TIMER = newTime
                if statusLabel then statusLabel:Set("Stabilize timer set to " .. newTime .. " seconds") end
            else
                if statusLabel then statusLabel:Set("Invalid timer value, using default (15s)") end
            end
        end
    })
    
    statusLabel = MainTab:CreateLabel("Ready")
    
    print("GUI setup complete with Rayfield")
    return true
end

local guiAvailable = setupGUI()

local stabilizeTimerActive = false
_G.stabilizeAndToggleWithTimer = function()
    local vehicle = getPlayerVehicle()
    if not vehicle then
        if statusLabel then statusLabel:Set("No vehicle found to stabilize!") end
        return
    end
    
    local primary = vehicle.PrimaryPart or vehicle:FindFirstChild("Body")
    if not primary then
        if statusLabel then statusLabel:Set("Vehicle has no primary part!") end
        return
    end
    
    local success, err = pcall(function()
        clearPhysicsObjects(primary)
        isHeadingToEnd = not isHeadingToEnd
        local directionText = isHeadingToEnd and "end point" or "start point"
        local direction = isHeadingToEnd and (END_POS - START_POS) or (START_POS - END_POS)
        local speed = speedInput and tonumber(speedInput.CurrentValue) or DEFAULT_SPEED
        
        setVehicleSpeed(vehicle, speed, direction)
        if statusLabel then statusLabel:Set("Stabilized & Direction: " .. directionText) end
    end)
    
    if not success then
        if statusLabel then statusLabel:Set("Stabilization failed: " .. tostring(err)) end
        return
    end
    
    if not stabilizeTimerActive then
        stabilizeTimerActive = true
        spawn(function()
            while true do
                if not stabilizeTimerActive then break end
                
                local remainingTime = STABILIZE_TIMER
                while remainingTime > 0 and stabilizeTimerActive do
                    if statusLabel then 
                        statusLabel:Set("Stabilize Timer: " .. math.floor(remainingTime) .. "s | Direction: " .. (isHeadingToEnd and "end" or "start") .. (antiAfkRunning and " | Anti-AFK: Active" or ""))
                    end
                    wait(1)
                    remainingTime = remainingTime - 1
                end
                
                if stabilizeTimerActive then
                    local newVehicle = getPlayerVehicle()
                    if newVehicle and newVehicle.PrimaryPart then
                        local toggleSuccess, toggleErr = pcall(function()
                            clearPhysicsObjects(newVehicle.PrimaryPart)
                            isHeadingToEnd = not isHeadingToEnd
                            local directionText = isHeadingToEnd and "end point" or "start point"
                            local direction = isHeadingToEnd and (END_POS - START_POS) or (START_POS - END_POS)
                            local speed = speedInput and tonumber(speedInput.CurrentValue) or DEFAULT_SPEED
                            setVehicleSpeed(newVehicle, speed, direction)
                            if statusLabel then statusLabel:Set("Timer reset: Direction toggled to " .. directionText) end
                        end)
                        if not toggleSuccess then
                            if statusLabel then statusLabel:Set("Toggle failed: " .. tostring(toggleErr) .. " - Retrying next cycle") end
                        end
                    else
                        if statusLabel then statusLabel:Set("Vehicle lost - Waiting for new vehicle") end
                        -- Wait for vehicle to reappear instead of stopping
                        repeat
                            wait(1)
                            newVehicle = getPlayerVehicle()
                        until newVehicle or not stabilizeTimerActive
                        if stabilizeTimerActive and newVehicle then
                            if statusLabel then statusLabel:Set("Vehicle reacquired - Continuing stabilization") end
                        end
                    end
                end
            end
            if statusLabel then statusLabel:Set("Stabilize timer stopped" .. (antiAfkRunning and " | Anti-AFK: Active" or "")) end
        end)
    end
end

_G.stopStabilizeTimer = function()
    stabilizeTimerActive = false
    if statusLabel then statusLabel:Set("Stabilization timer stopped" .. (antiAfkRunning and " | Anti-AFK: Active" or "")) end
end

RunService.RenderStepped:Connect(function()
    if autofarmRunning then
        local vehicle = getPlayerVehicle()
        if vehicle then
            maintainGroundLevel(vehicle)
            local primary = vehicle.PrimaryPart or vehicle:FindFirstChild("Body")
            if primary then
                local targetPos = isHeadingToEnd and END_POS or START_POS
                local distance = (primary.Position - targetPos).Magnitude
                if statusLabel then statusLabel:Set("Driving to " .. (isHeadingToEnd and "end" or "start") .. "... Distance: " .. math.floor(distance) .. (antiAfkRunning and " | Anti-AFK: Active" or "")) end
            end
        else
            if statusLabel then statusLabel:Set("Waiting for vehicle..." .. (antiAfkRunning and " | Anti-AFK: Active" or "")) end
        end
    end
end)

local function initializePhysics()
    local success, err = pcall(function()
        PhysicsService:CreateCollisionGroup("Vehicle")
        PhysicsService:CollisionGroupSetCollidable("Vehicle", "Default", true)
    end)
    if not success then warn("Physics initialization failed: " .. err) end
end

initializePhysics()

local function validatePositions()
    local startGround = raycastGround(START_POS)
    local endGround = raycastGround(END_POS)
    if not startGround or not endGround then
        if statusLabel then statusLabel:Set("Invalid positions detected!") end
        return false
    end
    return true
end

if validatePositions() then
    print("Vehicle Autofarm GUI loaded with robust stabilization and anti-AFK!")
else
    warn("Position validation failed!")
end

spawn(function()
    while wait(5) do
        if autofarmRunning then
            local vehicle = getPlayerVehicle()
            if vehicle then
                local primary = vehicle.PrimaryPart or vehicle:FindFirstChild("Body")
                if primary then
                    PhysicsService:SetPartCollisionGroup(primary, "Vehicle")
                end
            end
        end
    end
end)

spawn(function()
    for i = 1, 50 do
        wait(0.1)
        local vehicle = getPlayerVehicle()
        if vehicle then
            if statusLabel then statusLabel:Set("Vehicle detected, ready to start" .. (antiAfkRunning and " | Anti-AFK: Active" or "")) end
            break
        end
    end
end)
