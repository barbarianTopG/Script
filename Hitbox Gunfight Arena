local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "ComboChronicle Vault | Gunfight Arena",
    Icon = 12345678901, --  diamond icon ID? 
    LoadingTitle = "Loading ComboChronicle Vault ❖",
    LoadingSubtitle = "By COMBO_WICK | Bang.E.Line",
    Theme = "Ocean"
})

-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local HTTPService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")

-- Get the appropriate HTTP request function
local http_request = syn and syn.request or http and http.request or request or httprequest

-- Local Player
local LocalPlayer = Players.LocalPlayer

-- Constants
local THEME_COLOR = Color3.fromRGB(34, 193, 195) -- Teal
local ACCENT_COLOR = Color3.fromRGB(253, 187, 45) -- Gold
local COOLDOWN_SECONDS = 4500 -- 1 hour and 15 minutes
local WEBHOOK_URL = "https://discord.com/api/webhooks/1343326350458753105/sdvyj2pSzbP8X7B2AgX17e2NWiZowvxNfHOeIFcNT6UMxJpaHqOqEpG7WwxLxbsqc3VP"

-- Toggles
local aimAssistEnabled = false
local aimFOV = 100
local aimPart = "Head"
local teamCheck = true
local visualizeFOV = true
local hitChance = 100
local aimRandomization = 0.1
local aimPrediction = 0.1
local fovCircle = nil

-- Toggles
local aimbotEnabled = false
local autoLockEnabled = false
local trickshotMode = false
local npcESPEnabled = false
local npcHitboxEnabled = false
local fovRadius = 100
local aimPart = "Head" -- Options: "Head", "Torso", "Random"
local smoothingFactor = 5 -- Higher = slower and smoother aiming


-- Variables
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()
local currentResponse = ""
local lastFeedbackTime = 0


-- Aimbot Settings
getgenv().Aimbot = {
    Enabled = false,
    TeamCheck = true,
    TargetPart = "Head",
    FOV = 500,
    Smoothness = 0.5
}

local espEnabled = false
local hitboxEnabled = false
local wallbangEnabled = false
local wallbangRange = 500 -- Maximum penetration distance
local wallbangMaxWalls = 3 -- Maximum number of walls to penetrate
local wallbangIgnoreTransparent = true -- Ignore transparent parts
local targetEnemiesOnly = true -- Only target enemies, not teammates
local preferHeadshots = true -- Prefer headshots when possible
local visualizeRays = false -- Debug visualization of penetration rays
local silentAimEnabled = false
local silentAimFOV = 100
local silentAimPart = "Head"
local silentAimTeamCheck = true
local silentAimVisualizeCircle = true
local silentAimHitChance = 100
local silentAimSmoothing = 0.5
local silentAimFOVCircle = nil
local silentAimRandomization = 0.1
local silentAimPrediction = 0.1

-- Utility Functions
local function formatTime(seconds)
    local hours = math.floor(seconds / 3600)
    local minutes = math.floor((seconds % 3600) / 60)
    local secs = math.floor(seconds % 60)
    
    if hours > 0 then
        return string.format("%d hours, %d minutes", hours, minutes)
    elseif minutes > 0 then
        return string.format("%d minutes, %d seconds", minutes, secs)
    else
        return string.format("%d seconds", secs)
    end
end

local function sendWebhook(embedData)
    local success, response = pcall(function()
        local http_request = syn and syn.request or http and http.request or request or httprequest
        return http_request({
            Url = WEBHOOK_URL,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = HTTPService:JSONEncode({ embeds = { embedData } })
        })
    end)
    return success
end

-- Send Initial Execution Webhook
local function sendExecutionWebhook()
    local embedData = {
        title = "🚀 Script Execution",
        description = string.format("**%s** has launched the Response System", Players.LocalPlayer.DisplayName),
        color = 7419530,
        fields = {
            {
                name = "🔑 Hardware ID",
                value = "```" .. game:GetService("RbxAnalyticsService"):GetClientId() .. "```",
                inline = true
            },
            {
                name = "🎮 Game ID",
                value = "```" .. game.PlaceId .. "```",
                inline = true
            }
        },
        footer = {
            text = "Response System v2.0"
        },
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    sendWebhook(embedData)
end

-- Function to enable infinite jump
local infiniteJumpEnabled = false
game:GetService("UserInputService").JumpRequest:Connect(function()
    if infiniteJumpEnabled then
        game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState("Jumping")
    end
end)

-- Function for speed and jump power modification
local function modifyCharacterStats(speed, jump)
    local player = game.Players.LocalPlayer
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        player.Character.Humanoid.WalkSpeed = speed
        player.Character.Humanoid.JumpPower = jump
    end
end

-- Function for no clip
local noclipEnabled = false
game:GetService('RunService').Stepped:Connect(function()
    if noclipEnabled then
        for _, part in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end
end)

-- Function for auto respawn
local function autoRespawn()
    local player = game.Players.LocalPlayer
    if player.Character then
        player.Character:BreakJoints()
    end
end

-- Function to get the nearest player
local function GetClosest()
    local Target = nil
    local Closest = math.huge
    local mousePos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

    for _,v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 and v.Character:FindFirstChild(getgenv().Aimbot.TargetPart) then
            if getgenv().Aimbot.TeamCheck and v.Team == LocalPlayer.Team then continue end
            
            local pos = Camera:WorldToViewportPoint(v.Character[getgenv().Aimbot.TargetPart].Position)
            local Magnitude = (Vector2.new(pos.X, pos.Y) - mousePos).Magnitude

            if Magnitude < Closest and Magnitude <= getgenv().Aimbot.FOV then
                Closest = Magnitude
                Target = v
            end
        end
    end
    return Target
end

-- Main aimbot loop
RunService.RenderStepped:Connect(function()
    if getgenv().Aimbot.Enabled and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
        local Target = GetClosest()
        if Target and Target.Character and Target.Character:FindFirstChild(getgenv().Aimbot.TargetPart) then
            local pos = Target.Character[getgenv().Aimbot.TargetPart].Position
            Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, pos)
        end
    end
end)

-- Helper Functions
local function getClosestEnemyTarget()
    local localPlayer = game.Players.LocalPlayer
    local mouse = localPlayer:GetMouse()
    local closestDistance = fovRadius
    local closestPlayer = nil

    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild(aimPart) then
            local targetPart = player.Character[aimPart]

            -- Make sure it's an enemy, not a teammate (using Team-based checks)
            if player.Team ~= localPlayer.Team then
                local screenPosition, onScreen = workspace.CurrentCamera:WorldToScreenPoint(targetPart.Position)

                if onScreen then
                    local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude
                    if distance < closestDistance then
                        closestDistance = distance
                        closestPlayer = targetPart
                    end
                end
            end
        end
    end

    return closestPlayer
end

local function aimAtTarget(target)
    if target then
        local camera = workspace.CurrentCamera
        local targetPosition = target.Position
        local currentPosition = camera.CFrame.Position

        local direction = (targetPosition - currentPosition).Unit
        local newCFrame = CFrame.new(currentPosition, currentPosition + direction)

        camera.CFrame = camera.CFrame:Lerp(newCFrame, 1 / smoothingFactor)
    end
end

-- Main Aimbot Functionality
local function aimbotLoop()
    while task.wait() do
        if aimbotEnabled then
            local target = getClosestEnemyTarget()
            aimAtTarget(target)
        end
    end
end

task.spawn(aimbotLoop)

-- Create visualization circle
local function createFOVCircle()
    if not Drawing then return end
    
    fovCircle = Drawing.new("Circle")
    fovCircle.Visible = aimAssistEnabled and visualizeFOV
    fovCircle.Transparency = 0.7
    fovCircle.Color = Color3.fromRGB(255, 0, 0)
    fovCircle.Thickness = 1.5
    fovCircle.NumSides = 64
    fovCircle.Radius = aimFOV
    fovCircle.Filled = false
    
    -- Update position
    game:GetService("RunService").RenderStepped:Connect(function()
        if fovCircle then
            fovCircle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, 
                                           workspace.CurrentCamera.ViewportSize.Y / 2)
            fovCircle.Visible = aimAssistEnabled and visualizeFOV
        end
    end)
end

pcall(createFOVCircle)

-- Target acquisition - works with any game
local function getClosestTarget()
    local localPlayer = game.Players.LocalPlayer
    local camera = workspace.CurrentCamera
    local mousePos = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    local closestDistance = aimFOV
    local target = nil
    
    for _, player in pairs(game.Players:GetPlayers()) do
        if player == localPlayer then continue end
        if not player.Character then continue end
        
        -- Team check
        if teamCheck and player.Team == localPlayer.Team then continue end
        
        -- Verify player is alive
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        
        -- Handle different target part options
        local targetPart
        if aimPart == "Random" then
            local parts = {"Head", "HumanoidRootPart", "UpperTorso", "Torso", "LowerTorso"}
            for _, partName in ipairs(parts) do
                local part = player.Character:FindFirstChild(partName)
                if part then 
                    targetPart = part
                    break
                end
            end
        else
            -- Handle common alternative names
            if aimPart == "Torso" then
                targetPart = player.Character:FindFirstChild("Torso") or 
                            player.Character:FindFirstChild("UpperTorso")
            else
                targetPart = player.Character:FindFirstChild(aimPart)
            end
        end
        
        if not targetPart then continue end
        
        -- Screen position check
        local screenPos, onScreen = camera:WorldToScreenPoint(targetPart.Position)
        if not onScreen then continue end
        
        -- Distance to crosshair
        local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
        if distance < closestDistance then
            closestDistance = distance
            target = targetPart
        end
    end
    
    -- Apply hit chance
    if target and (math.random(1, 100) > hitChance) then
        return nil
    end
    
    return target
end

-- Movement prediction for targets
local function predictPosition(part)
    if not part or aimPrediction <= 0 then return part.Position end
    
    local character = part.Parent
    if not character then return part.Position end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return part.Position end
    
    -- Calculate velocity prediction
    local velocity = humanoid.MoveDirection * humanoid.WalkSpeed
    return part.Position + (velocity * aimPrediction)
end

-- Add randomization for natural-looking aiming
local function randomizeAim(position)
    if aimRandomization <= 0 then return position end
    
    local randomOffset = Vector3.new(
        (math.random() * 2 - 1) * aimRandomization,
        (math.random() * 2 - 1) * aimRandomization,
        (math.random() * 2 - 1) * aimRandomization
    )
    
    return position + randomOffset
end

-- Universal method hooks for all possible firing mechanisms
local hookSuccess = false

-- Hook method 1: Namecall for handling remote events and raycasting
pcall(function()
    local mt = getrawmetatable(game)
    if not mt then return end
    
    local oldNamecall = mt.__namecall
    setreadonly(mt, false)
    
    mt.__namecall = newcclosure(function(self, ...)
        local args = {...}
        local method = getnamecallmethod()
        
        if not aimAssistEnabled then
            return oldNamecall(self, unpack(args))
        end
        
        -- Cover shooting remotes
        if (method == "FireServer" or method == "InvokeServer") and 
           (self:IsA("RemoteEvent") or self:IsA("RemoteFunction")) then
            
            -- Modify Rays in arguments
            for i, arg in ipairs(args) do
                -- Direct Ray objects
                if typeof(arg) == "Ray" then
                    local target = getClosestTarget()
                    if target then
                        local targetPos = predictPosition(target)
                        targetPos = randomizeAim(targetPos)
                        
                        local origin = workspace.CurrentCamera.CFrame.Position
                        local direction = (targetPos - origin).Unit * 2000
                        args[i] = Ray.new(origin, direction)
                    end
                -- Table Ray format
                elseif type(arg) == "table" and arg.Origin and arg.Direction then
                    local target = getClosestTarget()
                    if target then
                        local targetPos = predictPosition(target)
                        targetPos = randomizeAim(targetPos)
                        
                        local origin = arg.Origin
                        arg.Direction = (targetPos - origin).Unit * 2000
                    end
                -- Vector3 position/direction pairs
                elseif i < #args and typeof(arg) == "Vector3" and typeof(args[i+1]) == "Vector3" then
                    local target = getClosestTarget()
                    if target then
                        local targetPos = predictPosition(target)
                        targetPos = randomizeAim(targetPos)
                        
                        args[i+1] = (targetPos - arg).Unit * 2000
                    end
                end
            end
        end
        
        -- Handle built-in raycasting methods
        if method == "FindPartOnRayWithIgnoreList" or 
           method == "FindPartOnRay" or
           method == "Raycast" then
            
            local target = getClosestTarget()
            if target then
                local targetPos = predictPosition(target)
                targetPos = randomizeAim(targetPos)
                
                local origin = workspace.CurrentCamera.CFrame.Position
                local direction = (targetPos - origin).Unit * 2000
                
                if method == "Raycast" then
                    -- Handle new Raycast format
                    args[1] = origin
                    args[2] = direction
                else
                    -- Handle legacy Ray format
                    args[1] = Ray.new(origin, direction)
                end
            end
        end
        
        return oldNamecall(self, unpack(args))
    end)
    
    hookSuccess = true
end)

-- Hook method 2: Index/NewIndex for direct mouse targeting
pcall(function()
    local mt = getrawmetatable(game)
    if not mt then return end
    
    local oldIndex = mt.__index
    local oldNewIndex = mt.__newindex
    setreadonly(mt, false)
    
    -- Handle mouse.Hit and mouse.Target properties
    mt.__index = newcclosure(function(self, key)
        if not aimAssistEnabled then 
            return oldIndex(self, key)
        end
        
        -- Detect mouse property access
        if key == "Hit" and self == game.Players.LocalPlayer:GetMouse() then
            local target = getClosestTarget()
            if target then
                local targetPos = predictPosition(target)
                targetPos = randomizeAim(targetPos)
                
                local origin = workspace.CurrentCamera.CFrame.Position
                local direction = (targetPos - origin).Unit * 2000
                
                return CFrame.new(origin, origin + direction)
            end
        elseif key == "Target" and self == game.Players.LocalPlayer:GetMouse() then
            local target = getClosestTarget()
            if target then
                return target
            end
        end
        
        return oldIndex(self, key)
    end)
    
    hookSuccess = true
end)

-- Hook method 3: Camera manipulation for direct camera-based aiming
local originalCameraCFrame
game:GetService("RunService").RenderStepped:Connect(function()
    if not aimAssistEnabled then 
        originalCameraCFrame = nil
        return 
    end
    
    local target = getClosestTarget()
    if not target then
        originalCameraCFrame = nil
        return
    end
    
    local camera = workspace.CurrentCamera
    
    -- Store original camera position
    if not originalCameraCFrame then
        originalCameraCFrame = camera.CFrame
    end
    
    -- Only manipulate when aiming (right mouse button)
    local userInputService = game:GetService("UserInputService")
    if userInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
        local targetPos = predictPosition(target)
        targetPos = randomizeAim(targetPos)
        
        -- Calculate smooth aim
        local currentCFrame = camera.CFrame
        local targetCFrame = CFrame.new(currentCFrame.Position, targetPos)
        
        -- Apply smooth interpolation
        camera.CFrame = currentCFrame:Lerp(targetCFrame, 0.2)
    else
        -- Reset camera when not aiming
        originalCameraCFrame = nil
    end
end)

-- Create custom hitboxes for all players
local function createHitbox(character)
    if not character then return end
    
    -- Don't create for teammates
    local player = game.Players:GetPlayerFromCharacter(character)
    if player and teamCheck and player.Team == game.Players.LocalPlayer.Team then
        return
    end
    
    -- Create hitbox for head
    local head = character:FindFirstChild("Head")
    if head and not head:FindFirstChild("AimHitbox") then
        local hitbox = Instance.new("Part")
        hitbox.Name = "AimHitbox"
        hitbox.Size = Vector3.new(4, 4, 4)
        hitbox.Transparency = 1
        hitbox.CanCollide = false
        hitbox.Massless = true
        hitbox.Parent = head
        
        local weld = Instance.new("WeldConstraint")
        weld.Part0 = head
        weld.Part1 = hitbox
        weld.Parent = hitbox
        
        -- Set collision properties for better hit detection
        hitbox.CollisionGroup = "PlayerHitbox"
    end
end

-- Apply hitboxes
local function applyHitboxes()
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer and player.Character then
            createHitbox(player.Character)
        end
    end
end

-- Monitor for new players/characters
game.Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        task.wait(0.5)
        createHitbox(character)
    end)
end)

-- Apply to existing players
for _, player in pairs(game.Players:GetPlayers()) do
    if player ~= game.Players.LocalPlayer then
        if player.Character then
            createHitbox(player.Character)
        end
        
        player.CharacterAdded:Connect(function(character)
            task.wait(0.5)
            createHitbox(character)
        end)
    end
end

-- Periodically refresh hitboxes
task.spawn(function()
    while true do
        task.wait(2)
        if aimAssistEnabled then
            applyHitboxes()
        end
    end
end)

-- Create FOV Circle for Silent Aim Visualization
local function createSilentAimFOVCircle()
    if not Drawing then
        warn("Drawing library not available")
        return
    end
    
    silentAimFOVCircle = Drawing.new("Circle")
    silentAimFOVCircle.Visible = silentAimEnabled and silentAimVisualizeCircle
    silentAimFOVCircle.Transparency = 0.7
    silentAimFOVCircle.Color = Color3.fromRGB(255, 0, 0)
    silentAimFOVCircle.Thickness = 1.5
    silentAimFOVCircle.NumSides = 64
    silentAimFOVCircle.Radius = silentAimFOV
    silentAimFOVCircle.Filled = false
end

-- Update FOV Circle Position
local function updateSilentAimFOVCircle()
    if silentAimFOVCircle then
        silentAimFOVCircle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
        silentAimFOVCircle.Radius = silentAimFOV
        silentAimFOVCircle.Visible = silentAimEnabled and silentAimVisualizeCircle
    end
end

-- Improved target prediction for moving players
local function predictTargetPosition(targetPart)
    if not targetPart or silentAimPrediction <= 0 then return targetPart.Position end
    
    local character = targetPart.Parent
    if not character then return targetPart.Position end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return targetPart.Position end
    
    -- Calculate velocity-based prediction
    local velocity = humanoid.MoveDirection * humanoid.WalkSpeed
    local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
    
    -- Apply prediction based on target velocity and ping
    return targetPart.Position + (velocity * silentAimPrediction * ping)
end

-- Get closest enemy for silent aim with improved detection
local function getSilentAimTarget()
    local localPlayer = game.Players.LocalPlayer
    local camera = workspace.CurrentCamera
    local mousePos = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    local closestDistance = silentAimFOV
    local closestPlayer = nil
    
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player == localPlayer then continue end
        if not player.Character then continue end
        
        -- Team check if enabled
        if silentAimTeamCheck and player.Team == localPlayer.Team then
            continue
        end
        
        -- Get humanoid and check if alive
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        
        -- Target part selection (handle "Random" option)
        local targetPart
        if silentAimPart == "Random" then
            local validParts = {"Head", "HumanoidRootPart", "Torso", "UpperTorso", "LowerTorso"}
            local randomIndex = math.random(1, #validParts)
            targetPart = player.Character:FindFirstChild(validParts[randomIndex])
        else
            -- Handle alternative part names
            if silentAimPart == "Torso" then
                targetPart = player.Character:FindFirstChild("Torso") or 
                              player.Character:FindFirstChild("UpperTorso")
            else
                targetPart = player.Character:FindFirstChild(silentAimPart)
            end
        end
        
        if not targetPart then continue end
        
        -- Check if on screen
        local screenPos, onScreen = camera:WorldToScreenPoint(targetPart.Position)
        if not onScreen then continue end
        
        -- Calculate distance to mouse
        local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
        if distance < closestDistance then
            closestDistance = distance
            closestPlayer = targetPart
        end
    end
    
    -- Random hit chance calculation
    if closestPlayer and (math.random(1, 100) > silentAimHitChance) then
        return nil
    end
    
    return closestPlayer
end

-- Add random offset to aim position for natural-looking shots
local function applyAimRandomization(position)
    if silentAimRandomization <= 0 then return position end
    
    local randomX = (math.random() * 2 - 1) * silentAimRandomization
    local randomY = (math.random() * 2 - 1) * silentAimRandomization
    local randomZ = (math.random() * 2 - 1) * silentAimRandomization
    
    return position + Vector3.new(randomX, randomY, randomZ)
end

-- Initialize FOV circle
pcall(function()
    createSilentAimFOVCircle()
    
    -- Update FOV circle when camera changes
    workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(updateSilentAimFOVCircle)
    
    -- Update FOV circle position periodically
    game:GetService("RunService").RenderStepped:Connect(updateSilentAimFOVCircle)
end)

-- Game-specific remote event detection
local gameRemotes = {}
local function findRemoteEvents()
    local success, result = pcall(function()
        for _, service in pairs(game:GetChildren()) do
            if service:IsA("ReplicatedStorage") or service:IsA("ReplicatedFirst") then
                for _, remote in pairs(service:GetDescendants()) do
                    if remote:IsA("RemoteEvent") and (
                       string.match(remote.Name:lower(), "fire") or
                       string.match(remote.Name:lower(), "shoot") or
                       string.match(remote.Name:lower(), "hit") or
                       string.match(remote.Name:lower(), "damage")
                    ) then
                        table.insert(gameRemotes, remote)
                    end
                end
            end
        end
    end)
    
    return #gameRemotes > 0
end

findRemoteEvents()

-- The main silent aim hook with better error handling and remote detection
local hookSuccessful = false
pcall(function()
    local mt = getrawmetatable(game)
    if not mt then return end
    
    local oldNamecall = mt.__namecall
    setreadonly(mt, false)
    
    mt.__namecall = newcclosure(function(self, ...)
        local args = {...}
        local method = getnamecallmethod()
        
        -- Only modify raycast/fireserver calls when silent aim is enabled
        if not silentAimEnabled then
            return oldNamecall(self, unpack(args))
        end
        
        -- Handle remote events
        if (method == "FireServer" or method == "InvokeServer") and 
           (self:IsA("RemoteEvent") or self:IsA("RemoteFunction")) then
            
            -- Check if this is a shooting remote
            local isShootingRemote = false
            if #gameRemotes > 0 then
                for _, remote in pairs(gameRemotes) do
                    if self == remote then
                        isShootingRemote = true
                        break
                    end
                end
            else
                -- Fallback detection logic
                isShootingRemote = (
                    string.match(self.Name:lower(), "fire") or 
                    string.match(self.Name:lower(), "shoot") or
                    string.match(self.Name:lower(), "hit") or
                    string.match(self.Name:lower(), "damage")
                )
            end
            
            if isShootingRemote then
                -- Process Ray arguments
                for i, arg in ipairs(args) do
                    if typeof(arg) == "Ray" then
                        local target = getSilentAimTarget()
                        if target then
                            -- Calculate target position with prediction
                            local targetPos = predictTargetPosition(target)
                            targetPos = applyAimRandomization(targetPos)
                            
                            -- Create new ray
                            local origin = workspace.CurrentCamera.CFrame.Position
                            local direction = (targetPos - origin).Unit * 2000
                            args[i] = Ray.new(origin, direction)
                        end
                    elseif type(arg) == "table" and arg.Origin and arg.Direction then
                        -- Handle custom ray structures
                        local target = getSilentAimTarget()
                        if target then
                            local targetPos = predictTargetPosition(target)
                            targetPos = applyAimRandomization(targetPos)
                            
                            local origin = arg.Origin
                            arg.Direction = (targetPos - origin).Unit * 2000
                        end
                    end
                end
            end
        end
        
        -- Handle built-in raycasting methods
        if method == "FindPartOnRayWithIgnoreList" or method == "FindPartOnRay" then
            local target = getSilentAimTarget()
            if target then
                local targetPos = predictTargetPosition(target)
                targetPos = applyAimRandomization(targetPos)
                
                local origin = workspace.CurrentCamera.CFrame.Position
                local direction = (targetPos - origin).Unit * 2000
                
                args[1] = Ray.new(origin, direction)
            end
        end
        
        return oldNamecall(self, unpack(args))
    end)
    
    hookSuccessful = true
end)

-- Enhanced magic bullet hitbox extender with error handling
local function createMagicBulletHitbox(character)
    if not silentAimEnabled or not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    -- Don't create hitbox for teammates if team check is enabled
    local player = game.Players:GetPlayerFromCharacter(character)
    if player and silentAimTeamCheck and player.Team == game.Players.LocalPlayer.Team then
        return
    end
    
    -- Create or update existing hitbox
    if not rootPart:FindFirstChild("MagicHitbox") then
        local hitbox = Instance.new("Part")
        hitbox.Name = "MagicHitbox"
        hitbox.Size = Vector3.new(5, 8, 5)
        hitbox.Transparency = 1
        hitbox.CanCollide = false
        hitbox.Massless = true
        hitbox.Anchored = false
        hitbox.Parent = rootPart
        
        local weld = Instance.new("WeldConstraint")
        weld.Part0 = rootPart
        weld.Part1 = hitbox
        weld.Parent = hitbox
    end
end

-- Apply magic hitboxes to all players
local function applyMagicHitboxes()
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer and player.Character then
            createMagicBulletHitbox(player.Character)
        end
    end
end

-- Monitor for new characters
game.Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        if silentAimEnabled then
            task.wait(0.5) -- Wait for character to fully load
            createMagicBulletHitbox(character)
        end
    end)
end)

-- Monitor existing players
for _, player in pairs(game.Players:GetPlayers()) do
    if player ~= game.Players.LocalPlayer then
        player.CharacterAdded:Connect(function(character)
            if silentAimEnabled then
                task.wait(0.5)
                createMagicBulletHitbox(character)
            end
        end)
        
        if player.Character then
            createMagicBulletHitbox(player.Character)
        end
    end
end

-- Update hitboxes periodically
task.spawn(function()
    while true do
        task.wait(1)
        if silentAimEnabled then
            applyMagicHitboxes()
        end
    end
end)

-- Helper function to determine if a player is an enemy
local function isEnemy(player)
    local localPlayer = game.Players.LocalPlayer
    if player == localPlayer then return false end
    
    -- Free-for-all mode
    if not targetEnemiesOnly then return true end
    
    -- Team check
    return player.Team ~= localPlayer.Team
end

-- Find target part (head or torso) in a character
local function findTargetPart(character)
    if preferHeadshots and character:FindFirstChild("Head") then
        return character.Head
    elseif character:FindFirstChild("HumanoidRootPart") then
        return character.HumanoidRootPart
    elseif character:FindFirstChild("UpperTorso") then
        return character.UpperTorso
    elseif character:FindFirstChild("Torso") then
        return character.Torso
    end
    return nil
end

-- Get all valid player targets
local function getTargetPlayers()
    local targets = {}
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer and player.Character and 
           player.Character:FindFirstChild("Humanoid") and 
           player.Character.Humanoid.Health > 0 and
           isEnemy(player) then
            
            local targetPart = findTargetPart(player.Character)
            if targetPart then
                table.insert(targets, {
                    player = player,
                    character = player.Character,
                    targetPart = targetPart
                })
            end
        end
    end
    return targets
end

-- Raycast function that can penetrate walls
local function wallbangRaycast()
    local camera = workspace.CurrentCamera
    local mousePos = game:GetService("UserInputService"):GetMouseLocation()
    local ray = camera:ViewportPointToRay(mousePos.X, mousePos.Y)
    
    local origin = ray.Origin
    local direction = ray.Direction * wallbangRange
    
    -- Get all potential targets
    local targets = getTargetPlayers()
    if #targets == 0 then return nil end
    
    -- Find all parts in the path
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {game.Players.LocalPlayer.Character}
    
    -- First raycast to find initial hit
    local raycastResult = workspace:Raycast(origin, direction, raycastParams)
    
    -- Keep track of passed walls
    local passedWalls = 0
    local currentOrigin = origin
    local ignoreList = {game.Players.LocalPlayer.Character}
    
    -- Visualize ray if enabled
    if visualizeRays then
        local lineStart = Instance.new("Part")
        lineStart.Shape = Enum.PartType.Ball
        lineStart.Size = Vector3.new(0.4, 0.4, 0.4)
        lineStart.Anchored = true
        lineStart.CanCollide = false
        lineStart.Position = origin
        lineStart.Material = Enum.Material.Neon
        lineStart.Color = Color3.fromRGB(255, 0, 0)
        lineStart.Transparency = 0.3
        lineStart.Parent = workspace
        game:GetService("Debris"):AddItem(lineStart, 3)
    end
    
    -- Loop to penetrate walls
    while passedWalls < wallbangMaxWalls do
        -- Check if we've hit something
        if raycastResult then
            -- Visualize hit point if enabled
            if visualizeRays then
                local hitPoint = Instance.new("Part")
                hitPoint.Shape = Enum.PartType.Ball
                hitPoint.Size = Vector3.new(0.4, 0.4, 0.4)
                hitPoint.Anchored = true
                hitPoint.CanCollide = false
                hitPoint.Position = raycastResult.Position
                hitPoint.Material = Enum.Material.Neon
                hitPoint.Color = Color3.fromRGB(255, 255, 0)
                hitPoint.Transparency = 0.3
                hitPoint.Parent = workspace
                game:GetService("Debris"):AddItem(hitPoint, 3)
            end
            
            -- Check if we hit a player
            local hitCharacter = raycastResult.Instance:FindFirstAncestorOfClass("Model")
            if hitCharacter and game.Players:GetPlayerFromCharacter(hitCharacter) then
                local hitPlayer = game.Players:GetPlayerFromCharacter(hitCharacter)
                if isEnemy(hitPlayer) then
                    -- We hit an enemy!
                    return raycastResult.Instance
                end
            end
            
            -- Skip transparent objects if enabled
            if wallbangIgnoreTransparent and raycastResult.Instance.Transparency > 0.8 then
                table.insert(ignoreList, raycastResult.Instance)
                raycastParams.FilterDescendantsInstances = ignoreList
                
                -- Update origin slightly past the hit point to avoid self-intersection
                local offsetVector = direction.Unit * 0.1
                currentOrigin = raycastResult.Position + offsetVector
                
                -- Continue raycast from new position
                raycastResult = workspace:Raycast(currentOrigin, direction, raycastParams)
                continue
            end
            
            -- Penetrate the wall
            passedWalls = passedWalls + 1
            table.insert(ignoreList, raycastResult.Instance)
            raycastParams.FilterDescendantsInstances = ignoreList
            
            -- Update origin slightly past the hit point to avoid self-intersection
            local offsetVector = direction.Unit * 0.1
            currentOrigin = raycastResult.Position + offsetVector
            
            -- Raycast to nearest target from behind the wall
            local closestTarget = nil
            local closestDistance = math.huge
            
            for _, targetData in ipairs(targets) do
                local targetPos = targetData.targetPart.Position
                local targetDirection = (targetPos - currentOrigin).Unit
                local targetDistance = (targetPos - currentOrigin).Magnitude
                
                -- Check if target is forward from current penetration point
                local dotProduct = direction.Unit:Dot(targetDirection)
                if dotProduct > 0.7 then  -- Target is roughly in the same direction
                    -- Raycast to this target
                    local targetRayParams = RaycastParams.new()
                    targetRayParams.FilterType = Enum.RaycastFilterType.Blacklist
                    targetRayParams.FilterDescendantsInstances = ignoreList
                    
                    local targetRaycastResult = workspace:Raycast(currentOrigin, targetDirection * targetDistance, targetRayParams)
                    if targetRaycastResult then
                        local hitModel = targetRaycastResult.Instance:FindFirstAncestorOfClass("Model")
                        if hitModel == targetData.character then
                            -- Direct hit to target through wall!
                            if visualizeRays then
                                local hitLine = Instance.new("Part")
                                hitLine.Shape = Enum.PartType.Ball
                                hitLine.Size = Vector3.new(0.4, 0.4, 0.4)
                                hitLine.Anchored = true
                                hitLine.CanCollide = false
                                hitLine.Position = targetRaycastResult.Position
                                hitLine.Material = Enum.Material.Neon
                                hitLine.Color = Color3.fromRGB(0, 255, 0)
                                hitLine.Transparency = 0.3
                                hitLine.Parent = workspace
                                game:GetService("Debris"):AddItem(hitLine, 3)
                            end
                            return targetRaycastResult.Instance
                        end
                    end
                    
                    -- If direct cast failed, check if this is the closest target
                    if targetDistance < closestDistance then
                        closestTarget = targetData
                        closestDistance = targetDistance
                    end
                end
            end
            
            -- Continue raycast forward
            raycastResult = workspace:Raycast(currentOrigin, direction, raycastParams)
            
            -- If no more hits but we have a close target, try to hit it
            if not raycastResult and closestTarget then
                local targetDirection = (closestTarget.targetPart.Position - currentOrigin).Unit
                local finalRayParams = RaycastParams.new()
                finalRayParams.FilterType = Enum.RaycastFilterType.Blacklist
                finalRayParams.FilterDescendantsInstances = ignoreList
                
                local finalRaycast = workspace:Raycast(currentOrigin, targetDirection * closestDistance, finalRayParams)
                if finalRaycast then
                    local hitModel = finalRaycast.Instance:FindFirstAncestorOfClass("Model")
                    if hitModel == closestTarget.character then
                        return finalRaycast.Instance
                    end
                end
                
                -- If we still haven't hit, just return the target part directly
                return closestTarget.targetPart
            end
        else
            -- No hit, try direct line to targets
            local closestTarget = nil
            local closestDistance = math.huge
            
            for _, targetData in ipairs(targets) do
                local targetPos = targetData.targetPart.Position
                local targetDirection = (targetPos - currentOrigin)
                local targetDistance = targetDirection.Magnitude
                targetDirection = targetDirection.Unit
                
                local targetRayParams = RaycastParams.new()
                targetRayParams.FilterType = Enum.RaycastFilterType.Blacklist
                targetRayParams.FilterDescendantsInstances = ignoreList
                
                local targetRaycastResult = workspace:Raycast(currentOrigin, targetDirection * targetDistance, targetRayParams)
                if targetRaycastResult then
                    local hitModel = targetRaycastResult.Instance:FindFirstAncestorOfClass("Model")
                    if hitModel == targetData.character then
                        return targetRaycastResult.Instance
                    end
                end
                
                if targetDistance < closestDistance then
                    closestTarget = targetData
                    closestDistance = targetDistance
                end
            end
            
            -- If we didn't hit anything but have a target, return it
            if closestTarget and closestDistance < wallbangRange then
                return closestTarget.targetPart
            end
            
            break
        end
    end
    
    return nil
end

-- Hook the game's shooting mechanism
local hookActive = false
local mt = getrawmetatable(game)

local function setupWallbangHook()
    if hookActive then return end
    
    local oldNamecall
    pcall(function()
        setreadonly(mt, false)
        oldNamecall = mt.__namecall
        
        mt.__namecall = newcclosure(function(self, ...)
            local method = getnamecallmethod()
            local args = {...}
            
            if wallbangEnabled and (method == "FindPartOnRayWithIgnoreList" or method == "FindPartOnRay") then
                -- This is likely a shooting function
                local wallbangTarget = wallbangRaycast()
                if wallbangTarget then
                    -- Get original ray info
                    local ray = args[1]
                    local origin = ray.Origin
                    
                    -- Create a fake ray result to the target
                    local fakeResult = {
                        Instance = wallbangTarget,
                        Position = wallbangTarget.Position,
                        Normal = Vector3.new(0, 1, 0),
                        Material = wallbangTarget.Material,
                    }
                    
                    return fakeResult
                end
            end
            
            if wallbangEnabled and (method == "FireServer" or method == "InvokeServer") and 
               (self:IsA("RemoteEvent") or self:IsA("RemoteFunction")) then
                
                -- Check if this is likely a shooting remote
                local isShootingRemote = string.match(self.Name:lower(), "fire") or 
                                        string.match(self.Name:lower(), "shoot") or
                                        string.match(self.Name:lower(), "hit") or
                                        string.match(self.Name:lower(), "damage")
                
                if isShootingRemote then
                    local wallbangTarget = wallbangRaycast()
                    if wallbangTarget then
                        -- Find and replace ray parameters
                        for i, arg in ipairs(args) do
                            if typeof(arg) == "Ray" then
                                local origin = arg.Origin
                                local direction = (wallbangTarget.Position - origin).Unit * 1000
                                args[i] = Ray.new(origin, direction)
                            elseif type(arg) == "table" and arg.Origin and arg.Direction then
                                -- Handle custom ray structures
                                local origin = arg.Origin
                                arg.Direction = (wallbangTarget.Position - origin).Unit * 1000
                            end
                        end
                    end
                end
            end
            
            return oldNamecall(self, unpack(args))
        end)
        
        hookActive = true
    end)
    
    -- Create observer for direct mouse input games
    local UserInputService = game:GetService("UserInputService")
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if wallbangEnabled and not gameProcessed then
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                local wallbangTarget = wallbangRaycast()
                -- The hook above will handle redirecting the shot
            end
        end
    end)
    
    print("Wallbang hook initialized successfully!")
end

-- Function to apply hitbox modifications (Original)
local function adjustHitbox(character)
    if not character then return end

    -- Ensure HumanoidRootPart hitbox is modified first
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if rootPart then
        rootPart.Size = Vector3.new(10, 10, 10) -- Adjust as needed
        rootPart.Transparency = 0.5 -- Debug visibility
        rootPart.CanCollide = false -- Disable collisions
    end

    -- Then modify the head hitbox
    local head = character:FindFirstChild("Head")
    if head then
        head.Size = Vector3.new(9, 9, 9) -- Expand hitbox size
        head.Transparency = 0.5 -- Debug visibility
        head.CanCollide = false -- Disable collisions
    end
end

-- Function to monitor a player (Original)
local function monitorPlayer(player)
    -- Check if player is on the same team
    local localPlayer = game.Players.LocalPlayer
    if player.Team == localPlayer.Team then return end

    -- Apply hitbox to existing character
    if player.Character then
        adjustHitbox(player.Character)
    end

    -- Listen for respawns
    player.CharacterAdded:Connect(function(character)
        adjustHitbox(character)
    end)
end

-- Monitor all players currently in the game (Original)
for _, player in pairs(game.Players:GetPlayers()) do
    if player ~= game.Players.LocalPlayer then
        monitorPlayer(player)
    end
end

-- Monitor new players joining (Original)
game.Players.PlayerAdded:Connect(function(player)
    if player ~= game.Players.LocalPlayer then
        monitorPlayer(player)
    end
end)

-- Continuously check for any missed players or characters (Original)
task.spawn(function()
    while task.wait(1) do
        for _, player in pairs(game.Players:GetPlayers()) do
            if player ~= game.Players.LocalPlayer and player.Team ~= game.Players.LocalPlayer.Team and player.Character then
                adjustHitbox(player.Character)
            end
        end
    end
end)

-- Function to add ESP to a character based on team (Original)
local function addESP(character, isTeammate)
    if character and character:FindFirstChild("Head") then
        if not character:FindFirstChild("ESP_Highlight") then
            local highlight = Instance.new("Highlight")
            highlight.Name = "ESP_Highlight"
            highlight.Adornee = character

            -- Set colors based on whether the player is a teammate
            if isTeammate then
                highlight.FillColor = Color3.new(0, 0, 0) -- Black for teammates
            else
                highlight.FillColor = Color3.new(1, 0, 0) -- Red for opponents
            end

            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Parent = character
        end
    end
end

-- Function to determine if a player is a teammate (Original)
local function isTeammate(player)
    local localPlayer = game.Players.LocalPlayer
    return player.Team == localPlayer.Team -- True if same team, false otherwise
end

-- Function to monitor a single player for ESP and Hitbox (Original)
local function monitorPlayerForESP(player)
    local localPlayer = game.Players.LocalPlayer

    -- Skip if the player is the local player
    if player == localPlayer then return end

    -- Add ESP to the current character
    if espEnabled and player.Character then
        addESP(player.Character, isTeammate(player))
    end

    -- Add ESP and hitbox when the character respawns
    player.CharacterAdded:Connect(function(character)
        if espEnabled then
            addESP(character, isTeammate(player))
        end
        if hitboxEnabled and not isTeammate(player) then
            adjustHitbox(character)
        end
    end)
end

-- Monitor all existing players for ESP and hitbox (Original)
for _, player in pairs(game.Players:GetPlayers()) do
    monitorPlayerForESP(player)
end

-- Monitor new players joining (Original)
game.Players.PlayerAdded:Connect(function(player)
    monitorPlayerForESP(player)
end)

-- Continuously check for any missed players or characters
task.spawn(function()
    while task.wait(1) do
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character then
                addESP(player.Character, isTeammate(player))
            end
        end
    end
end)

-- Helper Functions
local function getClosestEnemyTarget()
    local localPlayer = game.Players.LocalPlayer
    local mouse = localPlayer:GetMouse()
    local closestDistance = fovRadius
    local closestPlayer = nil

    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild(aimPart) then
            local targetPart = player.Character[aimPart]

            -- Make sure it's an enemy, not a teammate (using Team-based checks)
            if player.Team ~= localPlayer.Team then
                local screenPosition, onScreen = workspace.CurrentCamera:WorldToScreenPoint(targetPart.Position)

                if onScreen then
                    local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude
                    if distance < closestDistance then
                        closestDistance = distance
                        closestPlayer = targetPart
                    end
                end
            end
        end
    end

    return closestPlayer
end

local function aimAtTarget(target)
    if target then
        local camera = workspace.CurrentCamera
        local targetPosition = target.Position
        local currentPosition = camera.CFrame.Position

        local direction = (targetPosition - currentPosition).Unit
        local newCFrame = CFrame.new(currentPosition, currentPosition + direction)

        camera.CFrame = camera.CFrame:Lerp(newCFrame, 1 / smoothingFactor)
    end
end

-- Main Aimbot Functionality
local function aimbotLoop()
    while task.wait() do
        if aimbotEnabled then
            local target = getClosestEnemyTarget()
            aimAtTarget(target)
        end
    end
end

task.spawn(aimbotLoop)

-- NPC Functions
local function isNPC(character)
    if character and character:IsA("Model") then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        local head = character:FindFirstChild("Head")

        if humanoid and not Players:GetPlayerFromCharacter(character) then
            return true
        end
    end
    return false
end

local function addNPCESP(character)
    if character:FindFirstChild("ESPBox") then return end

    local esp = Instance.new("BillboardGui")
    esp.Name = "ESPBox"
    esp.AlwaysOnTop = true
    esp.Size = UDim2.new(4, 0, 2, 0)
    esp.StudsOffset = Vector3.new(0, 2, 0)

    local text = Instance.new("TextLabel", esp)
    text.Size = UDim2.new(1, 0, 1, 0)
    text.BackgroundTransparency = 1
    text.Text = "NPC"
    text.TextColor3 = Color3.fromRGB(255, 0, 0)
    text.TextStrokeTransparency = 0
    text.Font = Enum.Font.GothamBold
    text.TextSize = 16

    esp.Parent = character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")
end

local function expandNPCHitbox(character)
    if CollectionService:HasTag(character, "ModifiedNPC") then return end

    local head = character:FindFirstChild("Head")
    local rootPart = character:FindFirstChild("HumanoidRootPart")

    if head then
        head.Size = Vector3.new(9, 9, 9)
        head.Transparency = 0.5
        head.Material = Enum.Material.ForceField
    end

    if rootPart then
        rootPart.Size = Vector3.new(8, 8, 8)
        rootPart.Transparency = 0.5
        rootPart.Material = Enum.Material.ForceField
    end

    CollectionService:AddTag(character, "ModifiedNPC")
end

local function scanForNPCs()
    for _, v in pairs(Workspace:GetChildren()) do
        if isNPC(v) then
            if npcESPEnabled then
                addNPCESP(v)
            end
            if npcHitboxEnabled then
                expandNPCHitbox(v)
            end
        end
    end
end

-- Main Tab1
local mainTab = Window:CreateTab("Main", 4483362458)

local Label = mainTab:CreateLabel("NOTE: For some reason, it doesnt work good as how it should be working on some executors except solara. Trying to fix tht", 4483362458, Color3.fromRGB(34, 193, 34), false) -- Title, Icon, Color, IgnoreTheme

-- Toggle for enabling/disabling ESP (Original)
mainTab:CreateToggle({
    Name = "Enable ESP",
    CurrentValue = false, -- Default is off
    Flag = "espToggle",
    Callback = function(value)
        espEnabled = value
        if espEnabled then
            for _, player in pairs(game.Players:GetPlayers()) do
                if player.Character then
                    addESP(player.Character, isTeammate(player))
                end
            end
        else
            for _, player in pairs(game.Players:GetPlayers()) do
                if player.Character and player.Character:FindFirstChild("ESP_Highlight") then
                    player.Character.ESP_Highlight:Destroy()
                end
            end
        end
    end
})

-- Toggle for enabling/disabling Hitbox (Original)
mainTab:CreateToggle({
    Name = "Enable Hitbox",
    CurrentValue = false, -- Default is off
    Flag = "hitboxToggle",
    Callback = function(value)
        hitboxEnabled = value
        if hitboxEnabled then
            for _, player in pairs(game.Players:GetPlayers()) do
                if not isTeammate(player) and player.Character then
                    adjustHitbox(player.Character)
                end
            end
        else
            for _, player in pairs(game.Players:GetPlayers()) do
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    local rootPart = player.Character.HumanoidRootPart
                    rootPart.Size = Vector3.new(2, 2, 1) -- Reset to default size
                    rootPart.Transparency = 0 -- Reset visibility
                    rootPart.CanCollide = true -- Enable collisions
                end
            end
        end
    end
})

mainTab:CreateToggle({
    Name = "NPC ESP",
    CurrentValue = false,
    Flag = "npcESPToggle",
    Callback = function(value)
        npcESPEnabled = value
        if value then
            scanForNPCs()
        else
            -- Remove ESP
            for _, v in pairs(Workspace:GetDescendants()) do
                if v.Name == "ESPBox" then
                    v:Destroy()
                end
            end
        end
    end
})

mainTab:CreateToggle({
    Name = "NPC Hitbox Expander",
    CurrentValue = false,
    Flag = "npcHitboxToggle",
    Callback = function(value)
        npcHitboxEnabled = value
        if value then
            scanForNPCs()
        else
            -- Reset hitboxes
            for _, v in pairs(Workspace:GetChildren()) do
                if isNPC(v) and CollectionService:HasTag(v, "ModifiedNPC") then
                    local head = v:FindFirstChild("Head")
                    local rootPart = v:FindFirstChild("HumanoidRootPart")
                    
                    if head then
                        head.Size = Vector3.new(1, 1, 1)
                        head.Transparency = 0
                        head.Material = Enum.Material.Plastic
                    end
                    
                    if rootPart then
                        rootPart.Size = Vector3.new(2, 2, 1)
                        rootPart.Transparency = 0
                        rootPart.Material = Enum.Material.Plastic
                    end
                    
                    CollectionService:RemoveTag(v, "ModifiedNPC")
                end
            end
        end
    end
})

-- Monitor new NPCs
Workspace.ChildAdded:Connect(function(child)
    task.wait(0.1)
    if isNPC(child) then
        if npcESPEnabled then
            addNPCESP(child)
        end
        if npcHitboxEnabled then
            expandNPCHitbox(child)
        end
    end
end)

-- Initial scan
scanForNPCs()

mainTab:CreateSlider({
    Name = "Speed Hack",
    Range = {16, 500},
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = 16,
    Callback = function(Value)
        modifyCharacterStats(Value, game.Players.LocalPlayer.Character.Humanoid.JumpPower)
    end,
})

-- Jump Power Toggle
mainTab:CreateSlider({
    Name = "Jump Power",
    Range = {50, 500},
    Increment = 1,
    Suffix = "Power",
    CurrentValue = 50,
    Callback = function(Value)
        modifyCharacterStats(game.Players.LocalPlayer.Character.Humanoid.WalkSpeed, Value)
    end,
})

-- Infinite Jump Toggle
mainTab:CreateToggle({
    Name = "Infinite Jump",
    CurrentValue = false,
    Callback = function(Value)
        infiniteJumpEnabled = Value
    end,
})

-- Noclip Toggle
mainTab:CreateToggle({
    Name = "Noclip",
    CurrentValue = false,
    Callback = function(Value)
        noclipEnabled = Value
    end,
})

-- Auto Respawn Button
mainTab:CreateButton({
    Name = "Auto Respawn",
    Callback = function()
        autoRespawn()
    end,
})

-- God Mode Toggle
mainTab:CreateToggle({
    Name = "God Mode",
    CurrentValue = false,
    Callback = function(Value)
        local player = game.Players.LocalPlayer
        if player.Character then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid then
                if Value then
                    humanoid.MaxHealth = math.huge
                    humanoid.Health = math.huge
                else
                    humanoid.MaxHealth = 100
                    humanoid.Health = 100
                end
            end
        end
    end,
})

-- Credits Tab
local CreditsTab = Window:CreateTab("✨ Credits", "info")
local CreatorSection = CreditsTab:CreateSection("👑 Creator")
CreditsTab:CreateLabel("🛠️ COMBO_WICK - Discord: world_star_hacker")
local CoDevSection = CreditsTab:CreateSection("🤝 Co-Developer")
CreditsTab:CreateLabel("💡 None - Discord: None")
local DiscordSection = CreditsTab:CreateSection("🌐 Discord Server")
CreditsTab:CreateLabel("🔗 Join our server: discord.com/invite/mwTHaCKzhw")
CreditsTab:CreateButton({
   Name = "📋 Copy Discord Link/Youtube",
   Callback = function()
      local links = "Discord: discord.com/invite/mwTHaCKzhw\nYouTube: https://www.youtube.com/@COMBO_WICK"
      setclipboard(links)
   end,
})

-- GUI Elements
local MainTab = Window:CreateTab("AimbotV1", 12345678)

MainTab:CreateToggle({
    Name = "Enable Aim Assist",
    CurrentValue = false,
    Flag = "AimAssistToggle", 
    Callback = function(value)
        aimAssistEnabled = value
        if fovCircle then
            fovCircle.Visible = value and visualizeFOV
        end
        
        -- Apply hitboxes when enabled
        if value then
            applyHitboxes()
        end
    end,
})

MainTab:CreateToggle({
    Name = "Team Check",
    CurrentValue = true,
    Flag = "TeamCheck",
    Callback = function(value)
        teamCheck = value
    end,
})

MainTab:CreateToggle({
    Name = "Show FOV Circle",
    CurrentValue = true,
    Flag = "FOVCircle",
    Callback = function(value)
        visualizeFOV = value
        if fovCircle then
            fovCircle.Visible = aimAssistEnabled and value
        end
    end,
})

MainTab:CreateDropdown({
    Name = "Target Part",
    Options = {"Head", "HumanoidRootPart", "Torso", "Random"},
    CurrentOption = aimPart,
    Flag = "AimPart",
    Callback = function(option)
        aimPart = option
    end,
})

-- Status message
print("Universal aim assist loaded successfully!")
if hookSuccess then
    print("Hook methods installed successfully")
else
    warn("Some hook methods might have failed - aim assist might work partially")
end

local AimBotV2Section = MainTab:CreateSection("Aim-bot Auto Aim V2")
AimBotV2Section:Set("Auto Aim V2")

MainTab:CreateToggle({
    Name = "Enable Aimbot",
    CurrentValue = false,
    Callback = function(value)
        aimbotEnabled = value
    end,
})

MainTab:CreateToggle({
    Name = "Enable Auto-Lock",
    CurrentValue = false,
    Callback = function(value)
        autoLockEnabled = value
    end,
})

MainTab:CreateToggle({
    Name = "Enable Trickshot Mode",
    CurrentValue = false,
    Callback = function(value)
        trickshotMode = value
    end,
})

local AimBotV3Section = MainTab:CreateSection("Manual AimV3- Might crash you")
AimBotV3Section:Set("Manual Aim V3")

MainTab:CreateToggle({
    Name = "Enable Aimbot",
    CurrentValue = false,
    Flag = "AimbotEnabled",
    Callback = function(Value)
        getgenv().Aimbot.Enabled = Value
    end,
})

MainTab:CreateToggle({
    Name = "Team Check",
    CurrentValue = true,
    Flag = "TeamCheck",
    Callback = function(Value)
        getgenv().Aimbot.TeamCheck = Value
    end,
})

MainTab:CreateDropdown({
    Name = "Target Part",
    Options = {"Head", "HumanoidRootPart", "Torso"},
    CurrentOption = "Head",
    Flag = "TargetPart",
    Callback = function(Value)
        getgenv().Aimbot.TargetPart = Value
    end,
})

local WallbangSection = MainTab:CreateSection("Wallbang/Penetration")
WallbangSection:Set("WallBang Beta")

-- Add UI elements for Wallbang feature
MainTab:CreateToggle({
    Name = "Enable Wallbang/Penetration",
    CurrentValue = false,
    Flag = "WallbangToggle", 
    Callback = function(value)
        wallbangEnabled = value
        if value and not hookActive then
            setupWallbangHook()
        end
        print("Wallbang " .. (value and "enabled" or "disabled"))
    end,
})

MainTab:CreateToggle({
    Name = "Target Enemies Only",
    CurrentValue = true,
    Flag = "WallbangTeamCheck", 
    Callback = function(value)
        targetEnemiesOnly = value
    end,
})

MainTab:CreateToggle({
    Name = "Prefer Headshots",
    CurrentValue = true,
    Flag = "WallbangHeadshots", 
    Callback = function(value)
        preferHeadshots = value
    end,
})

MainTab:CreateToggle({
    Name = "Visualize Rays (Debug)",
    CurrentValue = false,
    Flag = "WallbangVisualizeRays", 
    Callback = function(value)
        visualizeRays = value
    end,
})

-- Initialize hook
setupWallbangHook()

local SilentAimSection = MainTab:CreateSection("Silent Aim")
SilentAimSection:Set("Silent AIm Beta")

MainTab:CreateToggle({
    Name = "Enable Silent Aim",
    CurrentValue = false,
    Flag = "SilentAimToggle", 
    Callback = function(value)
        silentAimEnabled = value
        if silentAimFOVCircle then
            silentAimFOVCircle.Visible = value and silentAimVisualizeCircle
        end
        
        -- Apply hitboxes immediately when enabled
        if value then
            applyMagicHitboxes()
        end
    end,
})

MainTab:CreateToggle({
    Name = "Team Check",
    CurrentValue = true,
    Flag = "SilentAimTeamCheck",
    Callback = function(value)
        silentAimTeamCheck = value
    end,
})

MainTab:CreateToggle({
    Name = "Show FOV Circle",
    CurrentValue = true,
    Flag = "SilentAimCircle",
    Callback = function(value)
        silentAimVisualizeCircle = value
        if silentAimFOVCircle then
            silentAimFOVCircle.Visible = silentAimEnabled and value
        end
    end,
})

MainTab:CreateDropdown({
    Name = "Target Part",
    Options = {"Head", "HumanoidRootPart", "Torso", "Random"},
    CurrentOption = silentAimPart,
    Flag = "SilentAimPart",
    Callback = function(option)
        silentAimPart = option
    end,
})

-- Message in console to verify the script is running
print("Silent aim module loaded successfully!")
if hookSuccessful then
    print("Namecall hook installed successfully!")
else
    warn("Failed to install namecall hook - silent aim may not work correctly")
end

--- Main Tab Creation
local ResponseTab = Window:CreateTab("📝 Responses", 4483362458)
local ResponseSection = ResponseTab:CreateSection("✉️ Message System")

-- Variable to store the current response
local currentResponse = ""

-- UI Elements
ResponseTab:CreateInput({
    Name = "💭 Your Message",
    PlaceholderText = "Share your thoughts or suggestions here...",
    RemoveTextAfterFocusLost = false,
    Callback = function(text)
        currentResponse = text
    end
})

ResponseTab:CreateButton({
    Name = "📤 Submit Response",
    Info = "Send your message to the development team",
    Interact = "Submit",
    Callback = function()
        local currentTime = tick()
        local timeRemaining = COOLDOWN_SECONDS - (currentTime - lastFeedbackTime)

        if timeRemaining > 0 then
            Rayfield:Notify({
                Title = "⏳ Cooldown Active",
                Content = "Please wait " .. formatTime(timeRemaining),
                Duration = 3,
                Image = 4483362458
            })
            return
        end

        if currentResponse == "" then
            Rayfield:Notify({
                Title = "❌ Error",
                Content = "Please enter a message before submitting",
                Duration = 3,
                Image = 4483362458
            })
            return
        end

        local embedData = {
            title = "📨 New Response",
            description = currentResponse,
            color = 3447003,
            fields = {
                {
                    name = "👤 User",
                    value = Players.LocalPlayer.DisplayName,
                    inline = true
                },
                {
                    name = "🆔 ID",
                    value = Players.LocalPlayer.UserId,
                    inline = true
                }
            },
            timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        }

        if sendWebhook(embedData) then
            Rayfield:Notify({
                Title = "✅ Success",
                Content = "Your message has been sent successfully!",
                Duration = 3,
                Image = 4483362458
            })
            lastFeedbackTime = currentTime
            currentResponse = ""
        else
            Rayfield:Notify({
                Title = "❌ Error",
                Content = "Failed to send message. Please try again later.",
                Duration = 3,
                Image = 4483362458
            })
        end
    end
})

-- Information Labels
ResponseTab:CreateLabel("⏰ Cooldown: 1 hour and 15 minutes between submissions")
ResponseTab:CreateLabel("💡 Share your suggestions for new features or improvements!")

-- Statistics Section
local StatsSection = ResponseTab:CreateSection("📊 Statistics")
local messagesSent = 0

ResponseTab:CreateLabel("Messages Sent Today: " .. messagesSent)

-- Initialize
sendExecutionWebhook()
